
// FOR_YOU: IMPORTANT WARNING:
// PLEASE, DON'T ADD OR CHANGE CODE TO THIS SOURCE! (trng.cpp)
// Since the "trng.cpp" source file will be updated after each new version of trng
// you could lose your code if you typed it here.
// Use the "PlugIn_trng.cpp" source to type your code and variables.

// don't remove following line: it's a way to keep memory about current release of your trng.cpp source
// #VERSION_UPDATE_INFO#=PU-8

#include "stdafx.h"
#include "bass.h"
#include <stdio.h>
#include <malloc.h>
#include <sys\stat.h>
#include <stdarg.h>
#include <math.h>

#ifdef LINK_TRNG
#include "..\Tomb_NextGeneration\Tomb_NextGeneration.h"
#include "..\Tomb_NextGeneration\structures.h"
#include "..\Tomb_NextGeneration\DefTomb4Funct.h"
#include "..\Tomb_NextGeneration\macros.h"
#else
#include "Tomb_NextGeneration.h" // mnemonic constants defined in tomb_NextGeneration.dll
#include "structures.h" // structure of tomb4 program and trng dll
#include "DefTomb4Funct.h" // defines of tomb4 procedure prototypes
#include "macros.h"  // definitions of macros used for "macro" commands
#endif		

#include "constants_mine.h"
#include "structures_mine.h"
#include "macros_mine.h"

#pragma warning( error : 4706 )
#pragma warning(disable: 4996)



// ---------------- GLOBAL STRUCTURES ------------------------------------------
// you'll use the "Trng" global variable to access to all trng data 
// In c++, you'll use the syntax:
// Trng.pGlobTomb4->  
// and now it will appear the list of members to choose..
// While in assembly you use it in this way:
//  mov  eax, dword ptr [Trng]
//  mov  ecx, dword ptr [eax+04h]  ; and now ECX points to the trng 
// data (pGlobTomb4)
// see the "Trng Plugin tutorial" for more infos.
StrTrngInfos Trng;
StrGetLocator GET;
StrFind FIND;
StrFloorAnalyse FLOOR;
StrLOFData LOF;
StrCollisionLast COLLIDE;
extern StrMyData MyData;
// temporary variables used by GetStaticOffset() macro
WORD TempStaticIndex;
WORD TempRoomIndex;




// In this trng.cpp source there are a list of procedures to get services
// from trng and other utilities.
// Some procedures call external trng services while others are built in 
// locally in this source 

// ------ variables and functions defined in other source (PlugIn_trng.cpp)

// functions
int MainPatcher(void);
extern TYPE_tombInviaLog tombInviaLog;
extern char TexMyPluginName[];
extern DWORD MyTomb4PatcherAddress;
extern TYPE_GetBestFrame GetBestFrame;
extern TYPE_GetFloor GetFloor;
extern TYPE_GetHeight GetHeight;
extern TYPE_GetCeiling GetCeiling;
extern TYPE_GetWaterHeight GetWaterHeight;
extern TYPE_GetWaterDepth GetWaterDepth;
extern TYPE_mGetAngle mGetAngle;
extern TYPE_LOS LOS;
extern TYPE_ObjectOnLOS2 ObjectOnLOS2;
extern TYPE_MoveLaraPosition MoveLaraPosition;
extern TYPE_ItemNewRoom ItemNewRoom;

// ------------- end of external variables and functions ------------

// -------------- GLOBAL VARIABLES  USED IN TRNG.CPP ----------------
char BufferLog[4096];

// --------------- END OF GLOBAL VARIABLES IN TRNG.CPP --------------

// ---------------- stuff for autoenumerate structure -------------------

// #TAG_START_AUTO_ENUM_STUFF#
StrEnumD3D enumD3D;
StrEnumCOLF enumCOLF;
StrEnumFIL enumFIL;
StrEnumSAVT enumSAVT;
StrEnumCONV enumCONV;
StrEnumFL enumFL;
StrEnumRIB enumRIB;
StrEnumWTF enumWTF;
StrEnumFT enumFT;
StrEnumFTS enumFTS;
StrEnumFC enumFC;
StrEnumPRET enumPRET;
StrEnumPHASE enumPHASE;
StrEnumIRET enumIRET;
StrEnumCPU enumCPU;
StrEnumAPPC enumAPPC;
StrEnumCB enumCB;
StrEnumSLOT enumSLOT;
StrEnumGET enumGET;
StrEnumSKIP enumSKIP;
StrEnumFL2 enumFL2;
StrEnumHOLD enumHOLD;
StrEnumLLF enumLLF;
StrEnumSCANF enumSCANF;
StrEnumMESH enumMESH;
StrEnumTRET enumTRET;
StrEnumCTRET enumCTRET;
StrEnumSRET enumSRET;
StrEnumJOINT enumJOINT;
StrEnumSC enumSC;
StrEnumSTRING enumSTRING;
StrEnumADD enumADD;
StrEnumENV enumENV;
StrEnumCBT enumCBT;
StrEnumFAN enumFAN;
StrEnumFLH enumFLH;
StrEnumCMD enumCMD;
StrEnumSRV enumSRV;
StrEnumSLEV enumSLEV;
StrEnumSMAIN enumSMAIN;
StrEnumEDGX enumEDGX;
StrEnumDGX enumDGX;
StrEnumFROOM enumFROOM;
StrEnumFIND enumFIND;
StrEnumSSLOT enumSSLOT;
StrEnumFWEAP enumFWEAP;
StrEnumCBEET enumCBEET;
StrEnumWSKIN enumWSKIN;
StrEnumCOMBO enumCOMBO;
StrEnumKCOMBO enumKCOMBO;
StrEnumEX16 enumEX16;
StrEnumPCOMBO enumPCOMBO;
StrEnumDENV enumDENV;
StrEnumSLOPE enumSLOPE;
StrEnumORIENT enumORIENT;
StrEnumFSLOT enumFSLOT;
StrEnumFITEM enumFITEM;
StrEnumMEMT enumMEMT;

void InitialiseEnums(void)
{
//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumD3D----------------------
	enumD3D.NO_LIGHT = D3D_NO_LIGHT;
	enumD3D.SUN = D3D_SUN;
	enumD3D.LIGHT = D3D_LIGHT;
	enumD3D.SPOT_OR_EFFECT = D3D_SPOT_OR_EFFECT;
	enumD3D.SHADOW = D3D_SHADOW;
	enumD3D.FOG_BULB = D3D_FOG_BULB;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCOLF----------------------
	enumCOLF.WINDOWS_COLOR = COLF_WINDOWS_COLOR;
	enumCOLF.TOMB_COLOR = COLF_TOMB_COLOR;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFIL----------------------
	enumFIL.FROM_SAVEGAME = FIL_FROM_SAVEGAME;
	enumFIL.FROM_NEW_LEVEL = FIL_FROM_NEW_LEVEL;
	enumFIL.FROM_LEVEL_JUMP = FIL_FROM_LEVEL_JUMP;
	enumFIL.PRESERVE_LARA = FIL_PRESERVE_LARA;
	enumFIL.PRESERVE_LEVEL = FIL_PRESERVE_LEVEL;
	enumFIL.FROM_LIKE_SAVEGAME = FIL_FROM_LIKE_SAVEGAME;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSAVT----------------------
	enumSAVT.LOCAL_DATA = SAVT_LOCAL_DATA;
	enumSAVT.GLOBAL_DATA = SAVT_GLOBAL_DATA;
	enumSAVT.COMPLETED = SAVT_COMPLETED;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCONV----------------------
	enumCONV.ItemIndexFromNgleToTomb = CONV_ItemIndexFromNgleToTomb;
	enumCONV.ItemIndexFromTombToNgle = CONV_ItemIndexFromTombToNgle;
	enumCONV.StaticIndexFromNgleToTomb = CONV_StaticIndexFromNgleToTomb;
	enumCONV.StaticIndexFromTombToNgle = CONV_StaticIndexFromTombToNgle;
	enumCONV.RectFromMicroUnitsToPixels = CONV_RectFromMicroUnitsToPixels;
	enumCONV.AnimIndexFromRelativeToAbs = CONV_AnimIndexFromRelativeToAbs;
	enumCONV.AnimIndexFromAbsToRelative = CONV_AnimIndexFromAbsToRelative;
	enumCONV.ItemFromStrItemTr4ToIndex = CONV_ItemFromStrItemTr4ToIndex;
	enumCONV.RoomIndexFromNgleToTomb = CONV_RoomIndexFromNgleToTomb;
	enumCONV.RoomIndexFromTombToNgle = CONV_RoomIndexFromTombToNgle;
	enumCONV.FrameIndexFromAbsToRelative = CONV_FrameIndexFromAbsToRelative;
	enumCONV.FrameIndexFromRelativeToAbs = CONV_FrameIndexFromRelativeToAbs;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFL----------------------
	enumFL.HOLDS_FLARE_OR_TORCH = FL_HOLDS_FLARE_OR_TORCH;
	enumFL.UNKNOWN_02 = FL_UNKNOWN_02;
	enumFL.SPECIAL_STATE = FL_SPECIAL_STATE;
	enumFL.IS_BURNING = FL_IS_BURNING;
	enumFL.ON_ALL_FOUR = FL_ON_ALL_FOUR;
	enumFL.SELF_ALIGNMENT = FL_SELF_ALIGNMENT;
	enumFL.UNDER_MONKEY_SECTOR = FL_UNDER_MONKEY_SECTOR;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumRIB----------------------
	enumRIB.ONLY_DIGITS = RIB_ONLY_DIGITS;
	enumRIB.ONLY_LETTERS = RIB_ONLY_LETTERS;
	enumRIB.HIDE_CARET = RIB_HIDE_CARET;
	enumRIB.BLINK_CARET = RIB_BLINK_CARET;
	enumRIB.SOUND_ON_KEY = RIB_SOUND_ON_KEY;
	enumRIB.PRINT_ONLY = RIB_PRINT_ONLY;
	enumRIB.ALIGN_CENTER = RIB_ALIGN_CENTER;
	enumRIB.ONLY_CAPS = RIB_ONLY_CAPS;
	enumRIB.PRINT_BIG_TEXT = RIB_PRINT_BIG_TEXT;
	enumRIB.INPUT_BELOW_BIG_TEXT = RIB_INPUT_BELOW_BIG_TEXT;
	enumRIB.ADD_SCANCODE_LIST = RIB_ADD_SCANCODE_LIST;
	enumRIB.SHORTCUT_KEY = RIB_SHORTCUT_KEY;
	enumRIB.HIDE_TEXT = RIB_HIDE_TEXT;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumWTF----------------------
	enumWTF.FLYING_TEXT = WTF_FLYING_TEXT;
	enumWTF.PULSING_TEXT = WTF_PULSING_TEXT;
	enumWTF.CHANGE_COLOR = WTF_CHANGE_COLOR;
	enumWTF.OVER_INVENTORY = WTF_OVER_INVENTORY;
	enumWTF.OVER_IMAGE = WTF_OVER_IMAGE;
	enumWTF.OVER_FLYCAMERA = WTF_OVER_FLYCAMERA;
	enumWTF.OVER_FIXCAMERA = WTF_OVER_FIXCAMERA;
	enumWTF.OVER_BINOCULAR = WTF_OVER_BINOCULAR;
	enumWTF.OVER_LASER_SIGHT = WTF_OVER_LASER_SIGHT;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFT----------------------
	enumFT.HALF_SIZEX = FT_HALF_SIZEX;
	enumFT.HALF_SIZEY = FT_HALF_SIZEY;
	enumFT.DOUBLE_SIZEX = FT_DOUBLE_SIZEX;
	enumFT.DOUBLE_SIZEY = FT_DOUBLE_SIZEY;
	enumFT.LITTLE_ALWAYS = FT_LITTLE_ALWAYS;
	enumFT.USE_FLOAT = FT_USE_FLOAT;
	enumFT.NO_BORDERS = FT_NO_BORDERS;
	enumFT.SIZE_ATOMIC_CHAR = FT_SIZE_ATOMIC_CHAR;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFTS----------------------
	enumFTS.ALIGN_LEFT = FTS_ALIGN_LEFT;
	enumFTS.STRETCH_TEXT = FTS_STRETCH_TEXT;
	enumFTS.BLINK = FTS_BLINK;
	enumFTS.ALIGN_RIGHT = FTS_ALIGN_RIGHT;
	enumFTS.ALIGN_CENTER = FTS_ALIGN_CENTER;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFC----------------------
	enumFC.WHITE_PULSE = FC_WHITE_PULSE;
	enumFC.WHITE = FC_WHITE;
	enumFC.RED = FC_RED;
	enumFC.BLUE = FC_BLUE;
	enumFC.LIGHT_GRAY = FC_LIGHT_GRAY;
	enumFC.GOLD = FC_GOLD;
	enumFC.DARK_GRAY = FC_DARK_GRAY;
	enumFC.YELLOW = FC_YELLOW;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPRET----------------------
	enumPRET.OK = PRET_OK;
	enumPRET.GO_TO_TITLE = PRET_GO_TO_TITLE;
	enumPRET.EXECUTE_ORIGINAL = PRET_EXECUTE_ORIGINAL;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPHASE----------------------
	enumPHASE.INVENTORY_MAIN = PHASE_INVENTORY_MAIN;
	enumPHASE.PAUSE_SCREEN = PHASE_PAUSE_SCREEN;
	enumPHASE.LOAD_GAME_PANEL = PHASE_LOAD_GAME_PANEL;
	enumPHASE.SAVE_GAME_PANEL = PHASE_SAVE_GAME_PANEL;
	enumPHASE.OPTIONS = PHASE_OPTIONS;
	enumPHASE.OPTION_COMMANDS = PHASE_OPTION_COMMANDS;
	enumPHASE.STATISTICS = PHASE_STATISTICS;
	enumPHASE.NEW_LEVEL = PHASE_NEW_LEVEL;
	enumPHASE.TITLE_MENU = PHASE_TITLE_MENU;
	enumPHASE.INVENTORY_EXAMINE = PHASE_INVENTORY_EXAMINE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumIRET----------------------
	enumIRET.OK = IRET_OK;
	enumIRET.SKIP_ORIGINAL = IRET_SKIP_ORIGINAL;
	enumIRET.LOADED_GAME = IRET_LOADED_GAME;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCPU----------------------
	enumCPU.CARRY = CPU_CARRY;
	enumCPU.PARITY = CPU_PARITY;
	enumCPU.ZERO = CPU_ZERO;
	enumCPU.SIGN = CPU_SIGN;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumAPPC----------------------
	enumAPPC.OK = APPC_OK;
	enumAPPC.WARN_PATCH_ALREADY_PERFORMED = APPC_WARN_PATCH_ALREADY_PERFORMED;
	enumAPPC.WARN_PLUGIN_REMOVED_RELOCATION_OF_PROCEDURE = APPC_WARN_PLUGIN_REMOVED_RELOCATION_OF_PROCEDURE;
	enumAPPC.WARN_PATCH_IN_A_RILOC_RESTORED_PROCEDURE = APPC_WARN_PATCH_IN_A_RILOC_RESTORED_PROCEDURE;
	enumAPPC.WARN_PATCH_OVER_OLD_PATCH = APPC_WARN_PATCH_OVER_OLD_PATCH;
	enumAPPC.WARN_PATCH_OVER_CHANGED_ARGUMENTS = APPC_WARN_PATCH_OVER_CHANGED_ARGUMENTS;
	enumAPPC.ERROR_PLUGIN_ID_UNREGISTERED = APPC_ERROR_PLUGIN_ID_UNREGISTERED;
	enumAPPC.ERROR_PATCH_OVERLAPPED_TO_RUNTIME_PATCH = APPC_ERROR_PATCH_OVERLAPPED_TO_RUNTIME_PATCH;
	enumAPPC.ERROR_PATCH_IN_RILOCATED_PROCEDURE = APPC_ERROR_PATCH_IN_RILOCATED_PROCEDURE;
	enumAPPC.ERROR_NOT_FOUND_TOMB4_IMAGE = APPC_ERROR_NOT_FOUND_TOMB4_IMAGE;
	enumAPPC.ERROR_RESTORE_ZONE_OUTSIDE_CODE_RANGE = APPC_ERROR_RESTORE_ZONE_OUTSIDE_CODE_RANGE;
	enumAPPC.ERROR_WRONG_PATCH_FOR_RUN_TIME = APPC_ERROR_WRONG_PATCH_FOR_RUN_TIME;
	enumAPPC.ERROR_PATCH_OUTSIDE_CODE_SEGMENT = APPC_ERROR_PATCH_OUTSIDE_CODE_SEGMENT;
	enumAPPC.ERROR_PATCH_OVERLAPPED_TO_RESERVED_ZONE = APPC_ERROR_PATCH_OVERLAPPED_TO_RESERVED_ZONE;
	enumAPPC.ERROR_RESERVED_ZONE_ALREADY_USED = APPC_ERROR_RESERVED_ZONE_ALREADY_USED;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCB----------------------
	enumCB.INIT_PROGRAM = CB_INIT_PROGRAM;
	enumCB.SAVING_GAME = CB_SAVING_GAME;
	enumCB.LOADING_GAME = CB_LOADING_GAME;
	enumCB.INIT_GAME = CB_INIT_GAME;
	enumCB.INIT_LOAD_NEW_LEVEL = CB_INIT_LOAD_NEW_LEVEL;
	enumCB.FLIPEFFECT_MINE = CB_FLIPEFFECT_MINE;
	enumCB.ACTION_MINE = CB_ACTION_MINE;
	enumCB.CONDITION_MINE = CB_CONDITION_MINE;
	enumCB.CUSTOMIZE_MINE = CB_CUSTOMIZE_MINE;
	enumCB.PARAMETER_MINE = CB_PARAMETER_MINE;
	enumCB.CYCLE_BEGIN = CB_CYCLE_BEGIN;
	enumCB.CYCLE_END = CB_CYCLE_END;
	enumCB.GLOBAL_TRIGGER = CB_GLOBAL_TRIGGER;
	enumCB.INIT_OBJECTS = CB_INIT_OBJECTS;
	enumCB.PROGR_ACTION_MINE = CB_PROGR_ACTION_MINE;
	enumCB.PROGR_ACTION_DRAW_MINE = CB_PROGR_ACTION_DRAW_MINE;
	enumCB.INIT_LEVEL = CB_INIT_LEVEL;
	enumCB.COMPLETED_PROGR_ACTION = CB_COMPLETED_PROGR_ACTION;
	enumCB.VEHICLE = CB_VEHICLE;
	enumCB.ASSIGN_SLOT_MINE = CB_ASSIGN_SLOT_MINE;
	enumCB.FMV_MANAGER = CB_FMV_MANAGER;
	enumCB.INPUT_MANAGER = CB_INPUT_MANAGER;
	enumCB.SAVEGAME_MANAGER = CB_SAVEGAME_MANAGER;
	enumCB.PAUSE_MANAGER = CB_PAUSE_MANAGER;
	enumCB.STATISTICS_MANAGER = CB_STATISTICS_MANAGER;
	enumCB.TITLE_MENU_MANAGER = CB_TITLE_MENU_MANAGER;
	enumCB.WINDOWS_FONT_CREATE = CB_WINDOWS_FONT_CREATE;
	enumCB.WINDOWS_UNICODE_CONVERT = CB_WINDOWS_UNICODE_CONVERT;
	enumCB.WINDOWS_TEXT_PRINT = CB_WINDOWS_TEXT_PRINT;
	enumCB.DIAGNOSTIC = CB_DIAGNOSTIC;
	enumCB.LARA_CONTROL = CB_LARA_CONTROL;
	enumCB.LARA_DRAW = CB_LARA_DRAW;
	enumCB.LARA_HAIR_DRAW = CB_LARA_HAIR_DRAW;
	enumCB.LARA_HAIR_CONTROL = CB_LARA_HAIR_CONTROL;
	enumCB.INVENTORY_MAIN = CB_INVENTORY_MAIN;
	enumCB.INVENT_BACKGROUND_CREATE = CB_INVENT_BACKGROUND_CREATE;
	enumCB.INVENT_BACKGROUND_DRAW = CB_INVENT_BACKGROUND_DRAW;
	enumCB.INVENT_BACKGROUND_QUIT = CB_INVENT_BACKGROUND_QUIT;
	enumCB.ANIMATE_LARA = CB_ANIMATE_LARA;
	enumCB.OPTIONS_MANAGER = CB_OPTIONS_MANAGER;
	enumCB.FLIPEFFECT = CB_FLIPEFFECT;
	enumCB.ACTION = CB_ACTION;
	enumCB.CONDITION = CB_CONDITION;
	enumCB.VEHICLE_CONTROL = CB_VEHICLE_CONTROL;
	enumCB.PROGR_ACTION = CB_PROGR_ACTION;
	enumCB.NUMERIC_TRNG_PATCH = CB_NUMERIC_TRNG_PATCH;
	enumCB.SLOT_INITIALISE = CB_SLOT_INITIALISE;
	enumCB.SLOT_CONTROL = CB_SLOT_CONTROL;
	enumCB.SLOT_COLLISION = CB_SLOT_COLLISION;
	enumCB.SLOT_DRAW = CB_SLOT_DRAW;
	enumCB.SLOT_FLOOR = CB_SLOT_FLOOR;
	enumCB.SLOT_CEILING = CB_SLOT_CEILING;
	enumCB.SLOT_DRAW_EXTRA = CB_SLOT_DRAW_EXTRA;
	enumCB.STATE_ID_LARA_CTRL = CB_STATE_ID_LARA_CTRL;
	enumCB.STATE_ID_LARA_COLLISION = CB_STATE_ID_LARA_COLLISION;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLOT----------------------
	enumSLOT.LARA = SLOT_LARA;
	enumSLOT.PISTOLS_ANIM = SLOT_PISTOLS_ANIM;
	enumSLOT.UZI_ANIM = SLOT_UZI_ANIM;
	enumSLOT.SHOTGUN_ANIM = SLOT_SHOTGUN_ANIM;
	enumSLOT.CROSSBOW_ANIM = SLOT_CROSSBOW_ANIM;
	enumSLOT.GRENADE_GUN_ANIM = SLOT_GRENADE_GUN_ANIM;
	enumSLOT.SIXSHOOTER_ANIM = SLOT_SIXSHOOTER_ANIM;
	enumSLOT.FLARE_ANIM = SLOT_FLARE_ANIM;
	enumSLOT.LARA_SKIN = SLOT_LARA_SKIN;
	enumSLOT.LARA_SKIN_JOINTS = SLOT_LARA_SKIN_JOINTS;
	enumSLOT.LARA_SCREAM = SLOT_LARA_SCREAM;
	enumSLOT.LARA_CROSSBOW_LASER = SLOT_LARA_CROSSBOW_LASER;
	enumSLOT.LARA_REVOLVER_LASER = SLOT_LARA_REVOLVER_LASER;
	enumSLOT.LARA_HOLSTERS = SLOT_LARA_HOLSTERS;
	enumSLOT.LARA_HOLSTERS_PISTOLS = SLOT_LARA_HOLSTERS_PISTOLS;
	enumSLOT.LARA_HOLSTERS_UZIS = SLOT_LARA_HOLSTERS_UZIS;
	enumSLOT.LARA_HOLSTERS_SIXSHOOTER = SLOT_LARA_HOLSTERS_SIXSHOOTER;
	enumSLOT.LARA_SPEECH_HEAD1 = SLOT_LARA_SPEECH_HEAD1;
	enumSLOT.LARA_SPEECH_HEAD2 = SLOT_LARA_SPEECH_HEAD2;
	enumSLOT.LARA_SPEECH_HEAD3 = SLOT_LARA_SPEECH_HEAD3;
	enumSLOT.LARA_SPEECH_HEAD4 = SLOT_LARA_SPEECH_HEAD4;
	enumSLOT.ACTOR1_SPEECH_HEAD1 = SLOT_ACTOR1_SPEECH_HEAD1;
	enumSLOT.ACTOR1_SPEECH_HEAD2 = SLOT_ACTOR1_SPEECH_HEAD2;
	enumSLOT.ACTOR2_SPEECH_HEAD1 = SLOT_ACTOR2_SPEECH_HEAD1;
	enumSLOT.ACTOR2_SPEECH_HEAD2 = SLOT_ACTOR2_SPEECH_HEAD2;
	enumSLOT.LARA_WATER_MESH = SLOT_LARA_WATER_MESH;
	enumSLOT.LARA_PETROL_MESH = SLOT_LARA_PETROL_MESH;
	enumSLOT.LARA_DIRT_MESH = SLOT_LARA_DIRT_MESH;
	enumSLOT.CROWBAR_ANIM = SLOT_CROWBAR_ANIM;
	enumSLOT.TORCH_ANIM = SLOT_TORCH_ANIM;
	enumSLOT.HAIR = SLOT_HAIR;
	enumSLOT.MOTORBIKE = SLOT_MOTORBIKE;
	enumSLOT.JEEP = SLOT_JEEP;
	enumSLOT.VEHICLE_EXTRA = SLOT_VEHICLE_EXTRA;
	enumSLOT.ENEMY_JEEP = SLOT_ENEMY_JEEP;
	enumSLOT.SKELETON = SLOT_SKELETON;
	enumSLOT.SKELETON_MIP = SLOT_SKELETON_MIP;
	enumSLOT.GUIDE = SLOT_GUIDE;
	enumSLOT.GUIDE_MIP = SLOT_GUIDE_MIP;
	enumSLOT.VON_CROY = SLOT_VON_CROY;
	enumSLOT.VON_CROY_MIP = SLOT_VON_CROY_MIP;
	enumSLOT.BADDY_1 = SLOT_BADDY_1;
	enumSLOT.BADDY_1_MIP = SLOT_BADDY_1_MIP;
	enumSLOT.BADDY_2 = SLOT_BADDY_2;
	enumSLOT.BADDY_2_MIP = SLOT_BADDY_2_MIP;
	enumSLOT.SETHA = SLOT_SETHA;
	enumSLOT.SETHA_MIP = SLOT_SETHA_MIP;
	enumSLOT.MUMMY = SLOT_MUMMY;
	enumSLOT.MUMMY_MIP = SLOT_MUMMY_MIP;
	enumSLOT.SPHINX = SLOT_SPHINX;
	enumSLOT.SPHINX_MIP = SLOT_SPHINX_MIP;
	enumSLOT.CROCODILE = SLOT_CROCODILE;
	enumSLOT.CROCODILE_MIP = SLOT_CROCODILE_MIP;
	enumSLOT.HORSEMAN = SLOT_HORSEMAN;
	enumSLOT.HORSEMAN_MIP = SLOT_HORSEMAN_MIP;
	enumSLOT.SCORPION = SLOT_SCORPION;
	enumSLOT.SCORPION_MIP = SLOT_SCORPION_MIP;
	enumSLOT.JEAN_YVES = SLOT_JEAN_YVES;
	enumSLOT.JEAN_YVES_MIP = SLOT_JEAN_YVES_MIP;
	enumSLOT.TROOPS = SLOT_TROOPS;
	enumSLOT.TROOPS_MIP = SLOT_TROOPS_MIP;
	enumSLOT.KNIGHTS_TEMPLAR = SLOT_KNIGHTS_TEMPLAR;
	enumSLOT.KNIGHTS_TEMPLAR_MIP = SLOT_KNIGHTS_TEMPLAR_MIP;
	enumSLOT.MUTANT = SLOT_MUTANT;
	enumSLOT.MUTANT_MIP = SLOT_MUTANT_MIP;
	enumSLOT.HORSE = SLOT_HORSE;
	enumSLOT.HORSE_MIP = SLOT_HORSE_MIP;
	enumSLOT.BABOON_NORMAL = SLOT_BABOON_NORMAL;
	enumSLOT.BABOON_NORMAL_MIP = SLOT_BABOON_NORMAL_MIP;
	enumSLOT.BABOON_INV = SLOT_BABOON_INV;
	enumSLOT.BABOON_INV_MIP = SLOT_BABOON_INV_MIP;
	enumSLOT.BABOON_SILENT = SLOT_BABOON_SILENT;
	enumSLOT.BABOON_SILENT_MIP = SLOT_BABOON_SILENT_MIP;
	enumSLOT.WILD_BOAR = SLOT_WILD_BOAR;
	enumSLOT.WILD_BOAR_MIP = SLOT_WILD_BOAR_MIP;
	enumSLOT.HARPY = SLOT_HARPY;
	enumSLOT.HARPY_MIP = SLOT_HARPY_MIP;
	enumSLOT.DEMIGOD1 = SLOT_DEMIGOD1;
	enumSLOT.DEMIGOD1_MIP = SLOT_DEMIGOD1_MIP;
	enumSLOT.DEMIGOD2 = SLOT_DEMIGOD2;
	enumSLOT.DEMIGOD2_MIP = SLOT_DEMIGOD2_MIP;
	enumSLOT.DEMIGOD3 = SLOT_DEMIGOD3;
	enumSLOT.DEMIGOD3_MIP = SLOT_DEMIGOD3_MIP;
	enumSLOT.LITTLE_BEETLE = SLOT_LITTLE_BEETLE;
	enumSLOT.BIG_BEETLE = SLOT_BIG_BEETLE;
	enumSLOT.BIG_BEETLE_MIP = SLOT_BIG_BEETLE_MIP;
	enumSLOT.WRAITH1 = SLOT_WRAITH1;
	enumSLOT.WRAITH2 = SLOT_WRAITH2;
	enumSLOT.WRAITH3 = SLOT_WRAITH3;
	enumSLOT.WRAITH4 = SLOT_WRAITH4;
	enumSLOT.BAT = SLOT_BAT;
	enumSLOT.DOG = SLOT_DOG;
	enumSLOT.DOG_MIP = SLOT_DOG_MIP;
	enumSLOT.HAMMERHEAD = SLOT_HAMMERHEAD;
	enumSLOT.HAMMERHEAD_MIP = SLOT_HAMMERHEAD_MIP;
	enumSLOT.SAS = SLOT_SAS;
	enumSLOT.SAS_MIP = SLOT_SAS_MIP;
	enumSLOT.SAS_DYING = SLOT_SAS_DYING;
	enumSLOT.SAS_DYING_MIP = SLOT_SAS_DYING_MIP;
	enumSLOT.SAS_CAPTAIN = SLOT_SAS_CAPTAIN;
	enumSLOT.SAS_CAPTAIN_MIP = SLOT_SAS_CAPTAIN_MIP;
	enumSLOT.SAS_DRAG_BLOKE = SLOT_SAS_DRAG_BLOKE;
	enumSLOT.AHMET = SLOT_AHMET;
	enumSLOT.AHMET_MIP = SLOT_AHMET_MIP;
	enumSLOT.LARA_DOUBLE = SLOT_LARA_DOUBLE;
	enumSLOT.LARA_DOUBLE_MIP = SLOT_LARA_DOUBLE_MIP;
	enumSLOT.SMALL_SCORPION = SLOT_SMALL_SCORPION;
	enumSLOT.LOCUST_EMITTER = SLOT_LOCUST_EMITTER;
	enumSLOT.GAME_PIECE1 = SLOT_GAME_PIECE1;
	enumSLOT.GAME_PIECE2 = SLOT_GAME_PIECE2;
	enumSLOT.GAME_PIECE3 = SLOT_GAME_PIECE3;
	enumSLOT.ENEMY_PIECE = SLOT_ENEMY_PIECE;
	enumSLOT.WHEEL_OF_FORTUNE = SLOT_WHEEL_OF_FORTUNE;
	enumSLOT.SCALES = SLOT_SCALES;
	enumSLOT.DARTS = SLOT_DARTS;
	enumSLOT.DART_EMITTER = SLOT_DART_EMITTER;
	enumSLOT.HOMING_DART_EMITTER = SLOT_HOMING_DART_EMITTER;
	enumSLOT.FALLING_CEILING = SLOT_FALLING_CEILING;
	enumSLOT.FALLING_BLOCK = SLOT_FALLING_BLOCK;
	enumSLOT.FALLING_BLOCK2 = SLOT_FALLING_BLOCK2;
	enumSLOT.SMASHABLE_BIKE_WALL = SLOT_SMASHABLE_BIKE_WALL;
	enumSLOT.SMASHABLE_BIKE_FLOOR = SLOT_SMASHABLE_BIKE_FLOOR;
	enumSLOT.TRAPDOOR1 = SLOT_TRAPDOOR1;
	enumSLOT.TRAPDOOR2 = SLOT_TRAPDOOR2;
	enumSLOT.TRAPDOOR3 = SLOT_TRAPDOOR3;
	enumSLOT.FLOOR_TRAPDOOR1 = SLOT_FLOOR_TRAPDOOR1;
	enumSLOT.FLOOR_TRAPDOOR2 = SLOT_FLOOR_TRAPDOOR2;
	enumSLOT.CEILING_TRAPDOOR1 = SLOT_CEILING_TRAPDOOR1;
	enumSLOT.CEILING_TRAPDOOR2 = SLOT_CEILING_TRAPDOOR2;
	enumSLOT.SCALING_TRAPDOOR = SLOT_SCALING_TRAPDOOR;
	enumSLOT.ROLLINGBALL = SLOT_ROLLINGBALL;
	enumSLOT.SPIKEY_FLOOR = SLOT_SPIKEY_FLOOR;
	enumSLOT.TEETH_SPIKES = SLOT_TEETH_SPIKES;
	enumSLOT.JOBY_SPIKES = SLOT_JOBY_SPIKES;
	enumSLOT.SLICER_DICER = SLOT_SLICER_DICER;
	enumSLOT.CHAIN = SLOT_CHAIN;
	enumSLOT.PLOUGH = SLOT_PLOUGH;
	enumSLOT.STARGATE = SLOT_STARGATE;
	enumSLOT.HAMMER = SLOT_HAMMER;
	enumSLOT.BURNING_FLOOR = SLOT_BURNING_FLOOR;
	enumSLOT.COG = SLOT_COG;
	enumSLOT.SPIKEBALL = SLOT_SPIKEBALL;
	enumSLOT.FLAME = SLOT_FLAME;
	enumSLOT.FLAME_EMITTER = SLOT_FLAME_EMITTER;
	enumSLOT.FLAME_EMITTER2 = SLOT_FLAME_EMITTER2;
	enumSLOT.FLAME_EMITTER3 = SLOT_FLAME_EMITTER3;
	enumSLOT.ROPE = SLOT_ROPE;
	enumSLOT.FIREROPE = SLOT_FIREROPE;
	enumSLOT.POLEROPE = SLOT_POLEROPE;
	enumSLOT.ONEBLOCK_PLATFORM = SLOT_ONEBLOCK_PLATFORM;
	enumSLOT.TWOBLOCK_PLATFORM = SLOT_TWOBLOCK_PLATFORM;
	enumSLOT.RAISING_BLOCK1 = SLOT_RAISING_BLOCK1;
	enumSLOT.RAISING_BLOCK2 = SLOT_RAISING_BLOCK2;
	enumSLOT.EXPANDING_PLATFORM = SLOT_EXPANDING_PLATFORM;
	enumSLOT.SQUISHY_BLOCK1 = SLOT_SQUISHY_BLOCK1;
	enumSLOT.SQUISHY_BLOCK2 = SLOT_SQUISHY_BLOCK2;
	enumSLOT.PUSHABLE_OBJECT1 = SLOT_PUSHABLE_OBJECT1;
	enumSLOT.PUSHABLE_OBJECT2 = SLOT_PUSHABLE_OBJECT2;
	enumSLOT.PUSHABLE_OBJECT3 = SLOT_PUSHABLE_OBJECT3;
	enumSLOT.PUSHABLE_OBJECT4 = SLOT_PUSHABLE_OBJECT4;
	enumSLOT.PUSHABLE_OBJECT5 = SLOT_PUSHABLE_OBJECT5;
	enumSLOT.TRIPWIRE = SLOT_TRIPWIRE;
	enumSLOT.SENTRY_GUN = SLOT_SENTRY_GUN;
	enumSLOT.MINE = SLOT_MINE;
	enumSLOT.MAPPER = SLOT_MAPPER;
	enumSLOT.OBELISK = SLOT_OBELISK;
	enumSLOT.FLOOR_4BLADE = SLOT_FLOOR_4BLADE;
	enumSLOT.ROOF_4BLADE = SLOT_ROOF_4BLADE;
	enumSLOT.BIRD_BLADE = SLOT_BIRD_BLADE;
	enumSLOT.CATWALK_BLADE = SLOT_CATWALK_BLADE;
	enumSLOT.MOVING_BLADE = SLOT_MOVING_BLADE;
	enumSLOT.PLINTH_BLADE = SLOT_PLINTH_BLADE;
	enumSLOT.SETH_BLADE = SLOT_SETH_BLADE;
	enumSLOT.LIGHTNING_CONDUCTOR = SLOT_LIGHTNING_CONDUCTOR;
	enumSLOT.ELEMENT_PUZZLE = SLOT_ELEMENT_PUZZLE;
	enumSLOT.PUZZLE_ITEM1 = SLOT_PUZZLE_ITEM1;
	enumSLOT.PUZZLE_ITEM2 = SLOT_PUZZLE_ITEM2;
	enumSLOT.PUZZLE_ITEM3 = SLOT_PUZZLE_ITEM3;
	enumSLOT.PUZZLE_ITEM4 = SLOT_PUZZLE_ITEM4;
	enumSLOT.PUZZLE_ITEM5 = SLOT_PUZZLE_ITEM5;
	enumSLOT.PUZZLE_ITEM6 = SLOT_PUZZLE_ITEM6;
	enumSLOT.PUZZLE_ITEM7 = SLOT_PUZZLE_ITEM7;
	enumSLOT.PUZZLE_ITEM8 = SLOT_PUZZLE_ITEM8;
	enumSLOT.PUZZLE_ITEM9 = SLOT_PUZZLE_ITEM9;
	enumSLOT.PUZZLE_ITEM10 = SLOT_PUZZLE_ITEM10;
	enumSLOT.PUZZLE_ITEM11 = SLOT_PUZZLE_ITEM11;
	enumSLOT.PUZZLE_ITEM12 = SLOT_PUZZLE_ITEM12;
	enumSLOT.PUZZLE_ITEM1_COMBO1 = SLOT_PUZZLE_ITEM1_COMBO1;
	enumSLOT.PUZZLE_ITEM1_COMBO2 = SLOT_PUZZLE_ITEM1_COMBO2;
	enumSLOT.PUZZLE_ITEM2_COMBO1 = SLOT_PUZZLE_ITEM2_COMBO1;
	enumSLOT.PUZZLE_ITEM2_COMBO2 = SLOT_PUZZLE_ITEM2_COMBO2;
	enumSLOT.PUZZLE_ITEM3_COMBO1 = SLOT_PUZZLE_ITEM3_COMBO1;
	enumSLOT.PUZZLE_ITEM3_COMBO2 = SLOT_PUZZLE_ITEM3_COMBO2;
	enumSLOT.PUZZLE_ITEM4_COMBO1 = SLOT_PUZZLE_ITEM4_COMBO1;
	enumSLOT.PUZZLE_ITEM4_COMBO2 = SLOT_PUZZLE_ITEM4_COMBO2;
	enumSLOT.PUZZLE_ITEM5_COMBO1 = SLOT_PUZZLE_ITEM5_COMBO1;
	enumSLOT.PUZZLE_ITEM5_COMBO2 = SLOT_PUZZLE_ITEM5_COMBO2;
	enumSLOT.PUZZLE_ITEM6_COMBO1 = SLOT_PUZZLE_ITEM6_COMBO1;
	enumSLOT.PUZZLE_ITEM6_COMBO2 = SLOT_PUZZLE_ITEM6_COMBO2;
	enumSLOT.PUZZLE_ITEM7_COMBO1 = SLOT_PUZZLE_ITEM7_COMBO1;
	enumSLOT.PUZZLE_ITEM7_COMBO2 = SLOT_PUZZLE_ITEM7_COMBO2;
	enumSLOT.PUZZLE_ITEM8_COMBO1 = SLOT_PUZZLE_ITEM8_COMBO1;
	enumSLOT.PUZZLE_ITEM8_COMBO2 = SLOT_PUZZLE_ITEM8_COMBO2;
	enumSLOT.KEY_ITEM1 = SLOT_KEY_ITEM1;
	enumSLOT.KEY_ITEM2 = SLOT_KEY_ITEM2;
	enumSLOT.KEY_ITEM3 = SLOT_KEY_ITEM3;
	enumSLOT.KEY_ITEM4 = SLOT_KEY_ITEM4;
	enumSLOT.KEY_ITEM5 = SLOT_KEY_ITEM5;
	enumSLOT.KEY_ITEM6 = SLOT_KEY_ITEM6;
	enumSLOT.KEY_ITEM7 = SLOT_KEY_ITEM7;
	enumSLOT.KEY_ITEM8 = SLOT_KEY_ITEM8;
	enumSLOT.KEY_ITEM9 = SLOT_KEY_ITEM9;
	enumSLOT.KEY_ITEM10 = SLOT_KEY_ITEM10;
	enumSLOT.KEY_ITEM11 = SLOT_KEY_ITEM11;
	enumSLOT.KEY_ITEM12 = SLOT_KEY_ITEM12;
	enumSLOT.KEY_ITEM1_COMBO1 = SLOT_KEY_ITEM1_COMBO1;
	enumSLOT.KEY_ITEM1_COMBO2 = SLOT_KEY_ITEM1_COMBO2;
	enumSLOT.KEY_ITEM2_COMBO1 = SLOT_KEY_ITEM2_COMBO1;
	enumSLOT.KEY_ITEM2_COMBO2 = SLOT_KEY_ITEM2_COMBO2;
	enumSLOT.KEY_ITEM3_COMBO1 = SLOT_KEY_ITEM3_COMBO1;
	enumSLOT.KEY_ITEM3_COMBO2 = SLOT_KEY_ITEM3_COMBO2;
	enumSLOT.KEY_ITEM4_COMBO1 = SLOT_KEY_ITEM4_COMBO1;
	enumSLOT.KEY_ITEM4_COMBO2 = SLOT_KEY_ITEM4_COMBO2;
	enumSLOT.KEY_ITEM5_COMBO1 = SLOT_KEY_ITEM5_COMBO1;
	enumSLOT.KEY_ITEM5_COMBO2 = SLOT_KEY_ITEM5_COMBO2;
	enumSLOT.KEY_ITEM6_COMBO1 = SLOT_KEY_ITEM6_COMBO1;
	enumSLOT.KEY_ITEM6_COMBO2 = SLOT_KEY_ITEM6_COMBO2;
	enumSLOT.KEY_ITEM7_COMBO1 = SLOT_KEY_ITEM7_COMBO1;
	enumSLOT.KEY_ITEM7_COMBO2 = SLOT_KEY_ITEM7_COMBO2;
	enumSLOT.KEY_ITEM8_COMBO1 = SLOT_KEY_ITEM8_COMBO1;
	enumSLOT.KEY_ITEM8_COMBO2 = SLOT_KEY_ITEM8_COMBO2;
	enumSLOT.PICKUP_ITEM1 = SLOT_PICKUP_ITEM1;
	enumSLOT.PICKUP_ITEM2 = SLOT_PICKUP_ITEM2;
	enumSLOT.PICKUP_ITEM3 = SLOT_PICKUP_ITEM3;
	enumSLOT.PICKUP_ITEM4 = SLOT_PICKUP_ITEM4;
	enumSLOT.PICKUP_ITEM1_COMBO1 = SLOT_PICKUP_ITEM1_COMBO1;
	enumSLOT.PICKUP_ITEM1_COMBO2 = SLOT_PICKUP_ITEM1_COMBO2;
	enumSLOT.PICKUP_ITEM2_COMBO1 = SLOT_PICKUP_ITEM2_COMBO1;
	enumSLOT.PICKUP_ITEM2_COMBO2 = SLOT_PICKUP_ITEM2_COMBO2;
	enumSLOT.PICKUP_ITEM3_COMBO1 = SLOT_PICKUP_ITEM3_COMBO1;
	enumSLOT.PICKUP_ITEM3_COMBO2 = SLOT_PICKUP_ITEM3_COMBO2;
	enumSLOT.PICKUP_ITEM4_COMBO1 = SLOT_PICKUP_ITEM4_COMBO1;
	enumSLOT.PICKUP_ITEM4_COMBO2 = SLOT_PICKUP_ITEM4_COMBO2;
	enumSLOT.EXAMINE1 = SLOT_EXAMINE1;
	enumSLOT.EXAMINE2 = SLOT_EXAMINE2;
	enumSLOT.EXAMINE3 = SLOT_EXAMINE3;
	enumSLOT.CROWBAR_ITEM = SLOT_CROWBAR_ITEM;
	enumSLOT.BURNING_TORCH_ITEM = SLOT_BURNING_TORCH_ITEM;
	enumSLOT.CLOCKWORK_BEETLE = SLOT_CLOCKWORK_BEETLE;
	enumSLOT.CLOCKWORK_BEETLE_COMBO1 = SLOT_CLOCKWORK_BEETLE_COMBO1;
	enumSLOT.CLOCKWORK_BEETLE_COMBO2 = SLOT_CLOCKWORK_BEETLE_COMBO2;
	enumSLOT.MINE_DETECTOR = SLOT_MINE_DETECTOR;
	enumSLOT.QUEST_ITEM1 = SLOT_QUEST_ITEM1;
	enumSLOT.QUEST_ITEM2 = SLOT_QUEST_ITEM2;
	enumSLOT.QUEST_ITEM3 = SLOT_QUEST_ITEM3;
	enumSLOT.QUEST_ITEM4 = SLOT_QUEST_ITEM4;
	enumSLOT.QUEST_ITEM5 = SLOT_QUEST_ITEM5;
	enumSLOT.QUEST_ITEM6 = SLOT_QUEST_ITEM6;
	enumSLOT.MAP = SLOT_MAP;
	enumSLOT.SECRET_MAP = SLOT_SECRET_MAP;
	enumSLOT.PUZZLE_HOLE1 = SLOT_PUZZLE_HOLE1;
	enumSLOT.PUZZLE_HOLE2 = SLOT_PUZZLE_HOLE2;
	enumSLOT.PUZZLE_HOLE3 = SLOT_PUZZLE_HOLE3;
	enumSLOT.PUZZLE_HOLE4 = SLOT_PUZZLE_HOLE4;
	enumSLOT.PUZZLE_HOLE5 = SLOT_PUZZLE_HOLE5;
	enumSLOT.PUZZLE_HOLE6 = SLOT_PUZZLE_HOLE6;
	enumSLOT.PUZZLE_HOLE7 = SLOT_PUZZLE_HOLE7;
	enumSLOT.PUZZLE_HOLE8 = SLOT_PUZZLE_HOLE8;
	enumSLOT.PUZZLE_HOLE9 = SLOT_PUZZLE_HOLE9;
	enumSLOT.PUZZLE_HOLE10 = SLOT_PUZZLE_HOLE10;
	enumSLOT.PUZZLE_HOLE11 = SLOT_PUZZLE_HOLE11;
	enumSLOT.PUZZLE_HOLE12 = SLOT_PUZZLE_HOLE12;
	enumSLOT.PUZZLE_DONE1 = SLOT_PUZZLE_DONE1;
	enumSLOT.PUZZLE_DONE2 = SLOT_PUZZLE_DONE2;
	enumSLOT.PUZZLE_DONE3 = SLOT_PUZZLE_DONE3;
	enumSLOT.PUZZLE_DONE4 = SLOT_PUZZLE_DONE4;
	enumSLOT.PUZZLE_DONE5 = SLOT_PUZZLE_DONE5;
	enumSLOT.PUZZLE_DONE6 = SLOT_PUZZLE_DONE6;
	enumSLOT.PUZZLE_DONE7 = SLOT_PUZZLE_DONE7;
	enumSLOT.PUZZLE_DONE8 = SLOT_PUZZLE_DONE8;
	enumSLOT.PUZZLE_DONE9 = SLOT_PUZZLE_DONE9;
	enumSLOT.PUZZLE_DONE10 = SLOT_PUZZLE_DONE10;
	enumSLOT.PUZZLE_DONE11 = SLOT_PUZZLE_DONE11;
	enumSLOT.PUZZLE_DONE12 = SLOT_PUZZLE_DONE12;
	enumSLOT.KEY_HOLE1 = SLOT_KEY_HOLE1;
	enumSLOT.KEY_HOLE2 = SLOT_KEY_HOLE2;
	enumSLOT.KEY_HOLE3 = SLOT_KEY_HOLE3;
	enumSLOT.KEY_HOLE4 = SLOT_KEY_HOLE4;
	enumSLOT.KEY_HOLE5 = SLOT_KEY_HOLE5;
	enumSLOT.KEY_HOLE6 = SLOT_KEY_HOLE6;
	enumSLOT.KEY_HOLE7 = SLOT_KEY_HOLE7;
	enumSLOT.KEY_HOLE8 = SLOT_KEY_HOLE8;
	enumSLOT.KEY_HOLE9 = SLOT_KEY_HOLE9;
	enumSLOT.KEY_HOLE10 = SLOT_KEY_HOLE10;
	enumSLOT.KEY_HOLE11 = SLOT_KEY_HOLE11;
	enumSLOT.KEY_HOLE12 = SLOT_KEY_HOLE12;
	enumSLOT.WATERSKIN1_EMPTY = SLOT_WATERSKIN1_EMPTY;
	enumSLOT.WATERSKIN1_1 = SLOT_WATERSKIN1_1;
	enumSLOT.WATERSKIN1_2 = SLOT_WATERSKIN1_2;
	enumSLOT.WATERSKIN1_3 = SLOT_WATERSKIN1_3;
	enumSLOT.WATERSKIN2_EMPTY = SLOT_WATERSKIN2_EMPTY;
	enumSLOT.WATERSKIN2_1 = SLOT_WATERSKIN2_1;
	enumSLOT.WATERSKIN2_2 = SLOT_WATERSKIN2_2;
	enumSLOT.WATERSKIN2_3 = SLOT_WATERSKIN2_3;
	enumSLOT.WATERSKIN2_4 = SLOT_WATERSKIN2_4;
	enumSLOT.WATERSKIN2_5 = SLOT_WATERSKIN2_5;
	enumSLOT.SWITCH_TYPE1 = SLOT_SWITCH_TYPE1;
	enumSLOT.SWITCH_TYPE2 = SLOT_SWITCH_TYPE2;
	enumSLOT.SWITCH_TYPE3 = SLOT_SWITCH_TYPE3;
	enumSLOT.SWITCH_TYPE4 = SLOT_SWITCH_TYPE4;
	enumSLOT.SWITCH_TYPE5 = SLOT_SWITCH_TYPE5;
	enumSLOT.SWITCH_TYPE6 = SLOT_SWITCH_TYPE6;
	enumSLOT.SWITCH_TYPE7 = SLOT_SWITCH_TYPE7;
	enumSLOT.SWITCH_TYPE8 = SLOT_SWITCH_TYPE8;
	enumSLOT.UNDERWATER_SWITCH1 = SLOT_UNDERWATER_SWITCH1;
	enumSLOT.UNDERWATER_SWITCH2 = SLOT_UNDERWATER_SWITCH2;
	enumSLOT.TURN_SWITCH = SLOT_TURN_SWITCH;
	enumSLOT.COG_SWITCH = SLOT_COG_SWITCH;
	enumSLOT.LEVER_SWITCH = SLOT_LEVER_SWITCH;
	enumSLOT.JUMP_SWITCH = SLOT_JUMP_SWITCH;
	enumSLOT.CROWBAR_SWITCH = SLOT_CROWBAR_SWITCH;
	enumSLOT.PULLEY = SLOT_PULLEY;
	enumSLOT.DOOR_TYPE1 = SLOT_DOOR_TYPE1;
	enumSLOT.DOOR_TYPE2 = SLOT_DOOR_TYPE2;
	enumSLOT.DOOR_TYPE3 = SLOT_DOOR_TYPE3;
	enumSLOT.DOOR_TYPE4 = SLOT_DOOR_TYPE4;
	enumSLOT.DOOR_TYPE5 = SLOT_DOOR_TYPE5;
	enumSLOT.DOOR_TYPE6 = SLOT_DOOR_TYPE6;
	enumSLOT.DOOR_TYPE7 = SLOT_DOOR_TYPE7;
	enumSLOT.DOOR_TYPE8 = SLOT_DOOR_TYPE8;
	enumSLOT.PUSHPULL_DOOR1 = SLOT_PUSHPULL_DOOR1;
	enumSLOT.PUSHPULL_DOOR2 = SLOT_PUSHPULL_DOOR2;
	enumSLOT.KICK_DOOR1 = SLOT_KICK_DOOR1;
	enumSLOT.KICK_DOOR2 = SLOT_KICK_DOOR2;
	enumSLOT.UNDERWATER_DOOR = SLOT_UNDERWATER_DOOR;
	enumSLOT.DOUBLE_DOORS = SLOT_DOUBLE_DOORS;
	enumSLOT.BRIDGE_FLAT = SLOT_BRIDGE_FLAT;
	enumSLOT.BRIDGE_TILT1 = SLOT_BRIDGE_TILT1;
	enumSLOT.BRIDGE_TILT2 = SLOT_BRIDGE_TILT2;
	enumSLOT.SARCOPHAGUS = SLOT_SARCOPHAGUS;
	enumSLOT.SEQUENCE_DOOR1 = SLOT_SEQUENCE_DOOR1;
	enumSLOT.SEQUENCE_SWITCH1 = SLOT_SEQUENCE_SWITCH1;
	enumSLOT.SEQUENCE_SWITCH2 = SLOT_SEQUENCE_SWITCH2;
	enumSLOT.SEQUENCE_SWITCH3 = SLOT_SEQUENCE_SWITCH3;
	enumSLOT.SARCOPHAGUS_CUT = SLOT_SARCOPHAGUS_CUT;
	enumSLOT.HORUS_STATUE = SLOT_HORUS_STATUE;
	enumSLOT.GOD_HEAD = SLOT_GOD_HEAD;
	enumSLOT.SETH_DOOR = SLOT_SETH_DOOR;
	enumSLOT.STATUE_PLINTH = SLOT_STATUE_PLINTH;
	enumSLOT.PISTOLS_ITEM = SLOT_PISTOLS_ITEM;
	enumSLOT.PISTOLS_AMMO_ITEM = SLOT_PISTOLS_AMMO_ITEM;
	enumSLOT.UZI_ITEM = SLOT_UZI_ITEM;
	enumSLOT.UZI_AMMO_ITEM = SLOT_UZI_AMMO_ITEM;
	enumSLOT.SHOTGUN_ITEM = SLOT_SHOTGUN_ITEM;
	enumSLOT.SHOTGUN_AMMO1_ITEM = SLOT_SHOTGUN_AMMO1_ITEM;
	enumSLOT.SHOTGUN_AMMO2_ITEM = SLOT_SHOTGUN_AMMO2_ITEM;
	enumSLOT.CROSSBOW_ITEM = SLOT_CROSSBOW_ITEM;
	enumSLOT.CROSSBOW_AMMO1_ITEM = SLOT_CROSSBOW_AMMO1_ITEM;
	enumSLOT.CROSSBOW_AMMO2_ITEM = SLOT_CROSSBOW_AMMO2_ITEM;
	enumSLOT.CROSSBOW_AMMO3_ITEM = SLOT_CROSSBOW_AMMO3_ITEM;
	enumSLOT.CROSSBOW_BOLT = SLOT_CROSSBOW_BOLT;
	enumSLOT.GRENADE_GUN_ITEM = SLOT_GRENADE_GUN_ITEM;
	enumSLOT.GRENADE_GUN_AMMO1_ITEM = SLOT_GRENADE_GUN_AMMO1_ITEM;
	enumSLOT.GRENADE_GUN_AMMO2_ITEM = SLOT_GRENADE_GUN_AMMO2_ITEM;
	enumSLOT.GRENADE_GUN_AMMO3_ITEM = SLOT_GRENADE_GUN_AMMO3_ITEM;
	enumSLOT.GRENADE = SLOT_GRENADE;
	enumSLOT.SIXSHOOTER_ITEM = SLOT_SIXSHOOTER_ITEM;
	enumSLOT.SIXSHOOTER_AMMO_ITEM = SLOT_SIXSHOOTER_AMMO_ITEM;
	enumSLOT.BIGMEDI_ITEM = SLOT_BIGMEDI_ITEM;
	enumSLOT.SMALLMEDI_ITEM = SLOT_SMALLMEDI_ITEM;
	enumSLOT.LASERSIGHT_ITEM = SLOT_LASERSIGHT_ITEM;
	enumSLOT.BINOCULARS_ITEM = SLOT_BINOCULARS_ITEM;
	enumSLOT.FLARE_ITEM = SLOT_FLARE_ITEM;
	enumSLOT.FLARE_INV_ITEM = SLOT_FLARE_INV_ITEM;
	enumSLOT.DIARY_ITEM = SLOT_DIARY_ITEM;
	enumSLOT.COMPASS_ITEM = SLOT_COMPASS_ITEM;
	enumSLOT.MEMCARD_LOAD_INV_ITEM = SLOT_MEMCARD_LOAD_INV_ITEM;
	enumSLOT.MEMCARD_SAVE_INV_ITEM = SLOT_MEMCARD_SAVE_INV_ITEM;
	enumSLOT.PC_LOAD_INV_ITEM = SLOT_PC_LOAD_INV_ITEM;
	enumSLOT.PC_SAVE_INV_ITEM = SLOT_PC_SAVE_INV_ITEM;
	enumSLOT.SMOKE_EMITTER_WHITE = SLOT_SMOKE_EMITTER_WHITE;
	enumSLOT.SMOKE_EMITTER_BLACK = SLOT_SMOKE_EMITTER_BLACK;
	enumSLOT.STEAM_EMITTER = SLOT_STEAM_EMITTER;
	enumSLOT.EARTHQUAKE = SLOT_EARTHQUAKE;
	enumSLOT.BUBBLES = SLOT_BUBBLES;
	enumSLOT.WATERFALLMIST = SLOT_WATERFALLMIST;
	enumSLOT.GUNSHELL = SLOT_GUNSHELL;
	enumSLOT.SHOTGUNSHELL = SLOT_SHOTGUNSHELL;
	enumSLOT.GUN_FLASH = SLOT_GUN_FLASH;
	enumSLOT.BUTTERFLY = SLOT_BUTTERFLY;
	enumSLOT.SPRINKLER = SLOT_SPRINKLER;
	enumSLOT.RED_LIGHT = SLOT_RED_LIGHT;
	enumSLOT.GREEN_LIGHT = SLOT_GREEN_LIGHT;
	enumSLOT.BLUE_LIGHT = SLOT_BLUE_LIGHT;
	enumSLOT.AMBER_LIGHT = SLOT_AMBER_LIGHT;
	enumSLOT.WHITE_LIGHT = SLOT_WHITE_LIGHT;
	enumSLOT.BLINKING_LIGHT = SLOT_BLINKING_LIGHT;
	enumSLOT.LENS_FLARE = SLOT_LENS_FLARE;
	enumSLOT.AI_GUARD = SLOT_AI_GUARD;
	enumSLOT.AI_AMBUSH = SLOT_AI_AMBUSH;
	enumSLOT.AI_PATROL1 = SLOT_AI_PATROL1;
	enumSLOT.AI_MODIFY = SLOT_AI_MODIFY;
	enumSLOT.AI_FOLLOW = SLOT_AI_FOLLOW;
	enumSLOT.AI_PATROL2 = SLOT_AI_PATROL2;
	enumSLOT.AI_X1 = SLOT_AI_X1;
	enumSLOT.AI_X2 = SLOT_AI_X2;
	enumSLOT.LARA_START_POS = SLOT_LARA_START_POS;
	enumSLOT.KILL_ALL_TRIGGERS = SLOT_KILL_ALL_TRIGGERS;
	enumSLOT.TRIGGER_TRIGGERER = SLOT_TRIGGER_TRIGGERER;
	enumSLOT.SMASH_OBJECT1 = SLOT_SMASH_OBJECT1;
	enumSLOT.SMASH_OBJECT2 = SLOT_SMASH_OBJECT2;
	enumSLOT.SMASH_OBJECT3 = SLOT_SMASH_OBJECT3;
	enumSLOT.SMASH_OBJECT4 = SLOT_SMASH_OBJECT4;
	enumSLOT.SMASH_OBJECT5 = SLOT_SMASH_OBJECT5;
	enumSLOT.SMASH_OBJECT6 = SLOT_SMASH_OBJECT6;
	enumSLOT.SMASH_OBJECT7 = SLOT_SMASH_OBJECT7;
	enumSLOT.SMASH_OBJECT8 = SLOT_SMASH_OBJECT8;
	enumSLOT.MESHSWAP1 = SLOT_MESHSWAP1;
	enumSLOT.MESHSWAP2 = SLOT_MESHSWAP2;
	enumSLOT.MESHSWAP3 = SLOT_MESHSWAP3;
	enumSLOT.DEATH_SLIDE = SLOT_DEATH_SLIDE;
	enumSLOT.BODY_PART = SLOT_BODY_PART;
	enumSLOT.CAMERA_TARGET = SLOT_CAMERA_TARGET;
	enumSLOT.WATERFALL1 = SLOT_WATERFALL1;
	enumSLOT.WATERFALL2 = SLOT_WATERFALL2;
	enumSLOT.WATERFALL3 = SLOT_WATERFALL3;
	enumSLOT.PLANET_EFFECT = SLOT_PLANET_EFFECT;
	enumSLOT.ANIMATING1 = SLOT_ANIMATING1;
	enumSLOT.ANIMATING1_MIP = SLOT_ANIMATING1_MIP;
	enumSLOT.ANIMATING2 = SLOT_ANIMATING2;
	enumSLOT.ANIMATING2_MIP = SLOT_ANIMATING2_MIP;
	enumSLOT.ANIMATING3 = SLOT_ANIMATING3;
	enumSLOT.ANIMATING3_MIP = SLOT_ANIMATING3_MIP;
	enumSLOT.ANIMATING4 = SLOT_ANIMATING4;
	enumSLOT.ANIMATING4_MIP = SLOT_ANIMATING4_MIP;
	enumSLOT.ANIMATING5 = SLOT_ANIMATING5;
	enumSLOT.ANIMATING5_MIP = SLOT_ANIMATING5_MIP;
	enumSLOT.ANIMATING6 = SLOT_ANIMATING6;
	enumSLOT.ANIMATING6_MIP = SLOT_ANIMATING6_MIP;
	enumSLOT.ANIMATING7 = SLOT_ANIMATING7;
	enumSLOT.ANIMATING7_MIP = SLOT_ANIMATING7_MIP;
	enumSLOT.ANIMATING8 = SLOT_ANIMATING8;
	enumSLOT.ANIMATING8_MIP = SLOT_ANIMATING8_MIP;
	enumSLOT.ANIMATING9 = SLOT_ANIMATING9;
	enumSLOT.ANIMATING9_MIP = SLOT_ANIMATING9_MIP;
	enumSLOT.ANIMATING10 = SLOT_ANIMATING10;
	enumSLOT.ANIMATING10_MIP = SLOT_ANIMATING10_MIP;
	enumSLOT.ANIMATING11 = SLOT_ANIMATING11;
	enumSLOT.ANIMATING11_MIP = SLOT_ANIMATING11_MIP;
	enumSLOT.ANIMATING12 = SLOT_ANIMATING12;
	enumSLOT.ANIMATING12_MIP = SLOT_ANIMATING12_MIP;
	enumSLOT.ANIMATING13 = SLOT_ANIMATING13;
	enumSLOT.ANIMATING13_MIP = SLOT_ANIMATING13_MIP;
	enumSLOT.ANIMATING14 = SLOT_ANIMATING14;
	enumSLOT.ANIMATING14_MIP = SLOT_ANIMATING14_MIP;
	enumSLOT.ANIMATING15 = SLOT_ANIMATING15;
	enumSLOT.ANIMATING15_MIP = SLOT_ANIMATING15_MIP;
	enumSLOT.ANIMATING16 = SLOT_ANIMATING16;
	enumSLOT.ANIMATING16_MIP = SLOT_ANIMATING16_MIP;
	enumSLOT.HORIZON = SLOT_HORIZON;
	enumSLOT.SKY_GRAPHICS = SLOT_SKY_GRAPHICS;
	enumSLOT.BINOCULAR_GRAPHICS = SLOT_BINOCULAR_GRAPHICS;
	enumSLOT.TARGET_GRAPHICS = SLOT_TARGET_GRAPHICS;
	enumSLOT.DEFAULT_SPRITES = SLOT_DEFAULT_SPRITES;
	enumSLOT.MISC_SPRITES = SLOT_MISC_SPRITES;
	enumSLOT.MOTOR_BOAT = SLOT_MOTOR_BOAT;
	enumSLOT.MOTOR_BOAT_LARA = SLOT_MOTOR_BOAT_LARA;
	enumSLOT.RUBBER_BOAT = SLOT_RUBBER_BOAT;
	enumSLOT.RUBBER_BOAT_LARA = SLOT_RUBBER_BOAT_LARA;
	enumSLOT.MOTORBIKE_LARA = SLOT_MOTORBIKE_LARA;
	enumSLOT.FONT_GRAPHICS = SLOT_FONT_GRAPHICS;
	enumSLOT.PARALLEL_BARS = SLOT_PARALLEL_BARS;
	enumSLOT.PANEL_BORDER = SLOT_PANEL_BORDER;
	enumSLOT.PANEL_MIDDLE = SLOT_PANEL_MIDDLE;
	enumSLOT.PANEL_CORNER = SLOT_PANEL_CORNER;
	enumSLOT.PANEL_DIAGONAL = SLOT_PANEL_DIAGONAL;
	enumSLOT.PANEL_STRIP = SLOT_PANEL_STRIP;
	enumSLOT.PANEL_HALF_BORDER1 = SLOT_PANEL_HALF_BORDER1;
	enumSLOT.PANEL_HALF_BORDER2 = SLOT_PANEL_HALF_BORDER2;
	enumSLOT.PANEL_MIDDLE_CORNER = SLOT_PANEL_MIDDLE_CORNER;
	enumSLOT.TIGHT_ROPE = SLOT_TIGHT_ROPE;
	enumSLOT.LASER_HEAD = SLOT_LASER_HEAD;
	enumSLOT.LASER_HEAD_BASE = SLOT_LASER_HEAD_BASE;
	enumSLOT.LASER_HEAD_TENTACLE = SLOT_LASER_HEAD_TENTACLE;
	enumSLOT.HYDRA = SLOT_HYDRA;
	enumSLOT.HYDRA_MISSILE = SLOT_HYDRA_MISSILE;
	enumSLOT.ENEMY_SUB_MARINE = SLOT_ENEMY_SUB_MARINE;
	enumSLOT.ENEMY_SUB_MARINE_MIP = SLOT_ENEMY_SUB_MARINE_MIP;
	enumSLOT.SUB_MARINE_MISSILE = SLOT_SUB_MARINE_MISSILE;
	enumSLOT.FROG_MAN = SLOT_FROG_MAN;
	enumSLOT.FROG_MAN_HARPOON = SLOT_FROG_MAN_HARPOON;
	enumSLOT.FISH_EMITTER = SLOT_FISH_EMITTER;
	enumSLOT.KAYAK = SLOT_KAYAK;
	enumSLOT.KAYAK_LARA = SLOT_KAYAK_LARA;
	enumSLOT.CUSTOM_SPRITES = SLOT_CUSTOM_SPRITES;
	enumSLOT.BRIDGE_TILT3 = SLOT_BRIDGE_TILT3;
	enumSLOT.BRIDGE_TILT4 = SLOT_BRIDGE_TILT4;
	enumSLOT.BRIDGE_CUSTOM = SLOT_BRIDGE_CUSTOM;
	enumSLOT.ROBOT_CLEANER = SLOT_ROBOT_CLEANER;
	enumSLOT.ROBOT_STAR_WARS = SLOT_ROBOT_STAR_WARS;
	enumSLOT.MECH_WARRIOR = SLOT_MECH_WARRIOR;
	enumSLOT.MECH_WARRIOR_LARA = SLOT_MECH_WARRIOR_LARA;
	enumSLOT.UW_PROPULSOR = SLOT_UW_PROPULSOR;
	enumSLOT.UW_PROPULSOR_LARA = SLOT_UW_PROPULSOR_LARA;
	enumSLOT.MINE_CART = SLOT_MINE_CART;
	enumSLOT.MINE_CART_LARA = SLOT_MINE_CART_LARA;
	enumSLOT.NEW_SLOT5 = SLOT_NEW_SLOT5;
	enumSLOT.NEW_SLOT6 = SLOT_NEW_SLOT6;
	enumSLOT.NEW_SLOT7 = SLOT_NEW_SLOT7;
	enumSLOT.NEW_SLOT8 = SLOT_NEW_SLOT8;
	enumSLOT.NEW_SLOT9 = SLOT_NEW_SLOT9;
	enumSLOT.NEW_SLOT10 = SLOT_NEW_SLOT10;
	enumSLOT.NEW_SLOT11 = SLOT_NEW_SLOT11;
	enumSLOT.NEW_SLOT12 = SLOT_NEW_SLOT12;
	enumSLOT.NEW_SLOT13 = SLOT_NEW_SLOT13;
	enumSLOT.NEW_SLOT14 = SLOT_NEW_SLOT14;
	enumSLOT.NEW_SLOT15 = SLOT_NEW_SLOT15;
	enumSLOT.NEW_SLOT16 = SLOT_NEW_SLOT16;
	enumSLOT.NEW_SLOT17 = SLOT_NEW_SLOT17;
	enumSLOT.NEW_SLOT18 = SLOT_NEW_SLOT18;
	enumSLOT.NUMBER_OBJECTS = SLOT_NUMBER_OBJECTS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumGET----------------------
	enumGET.LARA = GET_LARA;
	enumGET.ITEM = GET_ITEM;
	enumGET.STATIC = GET_STATIC;
	enumGET.ROOM = GET_ROOM;
	enumGET.ITEM_COLL_BOX = GET_ITEM_COLL_BOX;
	enumGET.STATIC_COLL_BOX = GET_STATIC_COLL_BOX;
	enumGET.STATIC_VIEW_BOX = GET_STATIC_VIEW_BOX;
	enumGET.DOOR_OF_ROOM = GET_DOOR_OF_ROOM;
	enumGET.INFO_LARA = GET_INFO_LARA;
	enumGET.MY_PARAMETER_COMMAND = GET_MY_PARAMETER_COMMAND;
	enumGET.MY_CUSTOMIZE_COMMAND = GET_MY_CUSTOMIZE_COMMAND;
	enumGET.INPUT = GET_INPUT;
	enumGET.STRINGNG = GET_STRINGNG;
	enumGET.STRING = GET_STRING;
	enumGET.BIG_NUMBER = GET_BIG_NUMBER;
	enumGET.SCRIPT_SETTINGS = GET_SCRIPT_SETTINGS;
	enumGET.PROGRESSIVE_ACTION = GET_PROGRESSIVE_ACTION;
	enumGET.AI_ITEM = GET_AI_ITEM;
	enumGET.LIGHT = GET_LIGHT;
	enumGET.CAMERA = GET_CAMERA;
	enumGET.CAMERA_FLY = GET_CAMERA_FLY;
	enumGET.COLOR_RGB = GET_COLOR_RGB;
	enumGET.GAME_INFO = GET_GAME_INFO;
	enumGET.SLOT = GET_SLOT;
	enumGET.INVENTORY = GET_INVENTORY;
	enumGET.ANIMATION = GET_ANIMATION;
	enumGET.INFO_ITEM = GET_INFO_ITEM;
	enumGET.VARIABLES = GET_VARIABLES;
	enumGET.FLIPMAPS = GET_FLIPMAPS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSKIP----------------------
	enumSKIP.NONE = SKIP_NONE;
	enumSKIP.FIXED_CAMERA = SKIP_FIXED_CAMERA;
	enumSKIP.FLY_CAMERA = SKIP_FLY_CAMERA;
	enumSKIP.LOADING_LEVEL = SKIP_LOADING_LEVEL;
	enumSKIP.FADE = SKIP_FADE;
	enumSKIP.TITLE_LEVEL = SKIP_TITLE_LEVEL;
	enumSKIP.GRAY_SCREEN = SKIP_GRAY_SCREEN;
	enumSKIP.NO_VIEW_OGGETTI = SKIP_NO_VIEW_OGGETTI;
	enumSKIP.BINOCULARS = SKIP_BINOCULARS;
	enumSKIP.LASER_SIGHT = SKIP_LASER_SIGHT;
	enumSKIP.FULL_IMAGE = SKIP_FULL_IMAGE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFL2----------------------
	enumFL2.OVER_MINE_TRIGGER = FL2_OVER_MINE_TRIGGER;
	enumFL2.IS_BURNING = FL2_IS_BURNING;
	enumFL2.IS_DUCK = FL2_IS_DUCK;
	enumFL2.IS_INVULNERABLE = FL2_IS_INVULNERABLE;
	enumFL2.IS_USING_LASER_SIGHT_OR_BINOCULARS = FL2_IS_USING_LASER_SIGHT_OR_BINOCULARS;
	enumFL2.TORCH_IS_BURNING = FL2_TORCH_IS_BURNING;
	enumFL2.IS_CLIMBING = FL2_IS_CLIMBING;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumHOLD----------------------
	enumHOLD.PISTOLS = HOLD_PISTOLS;
	enumHOLD.REVOLVER = HOLD_REVOLVER;
	enumHOLD.UZI = HOLD_UZI;
	enumHOLD.SHOTGUN = HOLD_SHOTGUN;
	enumHOLD.GRENADEGUN = HOLD_GRENADEGUN;
	enumHOLD.CROSSBOW = HOLD_CROSSBOW;
	enumHOLD.FLARE = HOLD_FLARE;
	enumHOLD.OUT_TORCH = HOLD_OUT_TORCH;
	enumHOLD.FIRED_TORCH = HOLD_FIRED_TORCH;
	enumHOLD.JEEP = HOLD_JEEP;
	enumHOLD.SIDECAR = HOLD_SIDECAR;
	enumHOLD.RUBBER_BOAT = HOLD_RUBBER_BOAT;
	enumHOLD.MOTOR_BOAT = HOLD_MOTOR_BOAT;
	enumHOLD.ROPE = HOLD_ROPE;
	enumHOLD.POLE = HOLD_POLE;
	enumHOLD.ANY_TORCH = HOLD_ANY_TORCH;
	enumHOLD.KAYAK = HOLD_KAYAK;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumLLF----------------------
	enumLLF.GROUND = LLF_GROUND;
	enumLLF.UNDERWATER = LLF_UNDERWATER;
	enumLLF.FLOATING = LLF_FLOATING;
	enumLLF.DOZY = LLF_DOZY;
	enumLLF.LOW_WATER = LLF_LOW_WATER;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSCANF----------------------
	enumSCANF.HEAVY = SCANF_HEAVY;
	enumSCANF.TEMP_ONE_SHOT = SCANF_TEMP_ONE_SHOT;
	enumSCANF.BUTTON_ONE_SHOT = SCANF_BUTTON_ONE_SHOT;
	enumSCANF.YET_TO_PERFORM = SCANF_YET_TO_PERFORM;
	enumSCANF.SCRIPT_TRIGGER = SCANF_SCRIPT_TRIGGER;
	enumSCANF.DIRECT_CALL = SCANF_DIRECT_CALL;
	enumSCANF.FLOOR_DATA = SCANF_FLOOR_DATA;
	enumSCANF.ANIM_COMMAND = SCANF_ANIM_COMMAND;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumMESH----------------------
	enumMESH.BUTT = MESH_BUTT;
	enumMESH.RIGHT_THIGH = MESH_RIGHT_THIGH;
	enumMESH.RIGHT_CALF = MESH_RIGHT_CALF;
	enumMESH.RIGHT_FOOT = MESH_RIGHT_FOOT;
	enumMESH.LEFT_THIGH = MESH_LEFT_THIGH;
	enumMESH.LEFT_CALF = MESH_LEFT_CALF;
	enumMESH.LEFT_FOOT = MESH_LEFT_FOOT;
	enumMESH.CHEST = MESH_CHEST;
	enumMESH.RIGHT_ARM = MESH_RIGHT_ARM;
	enumMESH.RIGHT_FOREARM = MESH_RIGHT_FOREARM;
	enumMESH.RIGHT_HAND = MESH_RIGHT_HAND;
	enumMESH.LEFT_ARM = MESH_LEFT_ARM;
	enumMESH.LEFT_FOREARM = MESH_LEFT_FOREARM;
	enumMESH.LEFT_HAND = MESH_LEFT_HAND;
	enumMESH.HEAD = MESH_HEAD;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumTRET----------------------
	enumTRET.PERFORM_ALWAYS = TRET_PERFORM_ALWAYS;
	enumTRET.PERFORM_ONCE_AND_GO = TRET_PERFORM_ONCE_AND_GO;
	enumTRET.PERFORM_NEVER_MORE = TRET_PERFORM_NEVER_MORE;
	enumTRET.EXECUTE_ORIGINAL = TRET_EXECUTE_ORIGINAL;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCTRET----------------------
	enumCTRET.IS_TRUE = CTRET_IS_TRUE;
	enumCTRET.EXTRA_PARAM = CTRET_EXTRA_PARAM;
	enumCTRET.ON_MOVEABLE = CTRET_ON_MOVEABLE;
	enumCTRET.PERFORM_ALWAYS = CTRET_PERFORM_ALWAYS;
	enumCTRET.ONLY_ONCE_ON_TRUE = CTRET_ONLY_ONCE_ON_TRUE;
	enumCTRET.NEVER_MORE_ON_TRUE = CTRET_NEVER_MORE_ON_TRUE;
	enumCTRET.PERFORM_ONCE_AND_GO = CTRET_PERFORM_ONCE_AND_GO;
	enumCTRET.EXECUTE_ORIGINAL = CTRET_EXECUTE_ORIGINAL;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSRET----------------------
	enumSRET.OK = SRET_OK;
	enumSRET.SKIP_ORIGINAL = SRET_SKIP_ORIGINAL;
	enumSRET.SKIP_TRNG_CODE = SRET_SKIP_TRNG_CODE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumJOINT----------------------
	enumJOINT.LEFT_THIGH = JOINT_LEFT_THIGH;
	enumJOINT.LEFT_KNEE = JOINT_LEFT_KNEE;
	enumJOINT.LEFT_ANCKLE = JOINT_LEFT_ANCKLE;
	enumJOINT.RIGHT_THIGH = JOINT_RIGHT_THIGH;
	enumJOINT.RIGHT_KNEE = JOINT_RIGHT_KNEE;
	enumJOINT.RIGHT_ANCKLE = JOINT_RIGHT_ANCKLE;
	enumJOINT.ABDOMEN = JOINT_ABDOMEN;
	enumJOINT.NECK = JOINT_NECK;
	enumJOINT.LEFT_SHOULDER = JOINT_LEFT_SHOULDER;
	enumJOINT.LEFT_ELBOW = JOINT_LEFT_ELBOW;
	enumJOINT.LEFT_WRIST = JOINT_LEFT_WRIST;
	enumJOINT.RIGHT_SHOULDER = JOINT_RIGHT_SHOULDER;
	enumJOINT.RIGHT_ELBOW = JOINT_RIGHT_ELBOW;
	enumJOINT.RIGHT_WRIST = JOINT_RIGHT_WRIST;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSC----------------------
	enumSC.NORMAL = SC_NORMAL;
	enumSC.HALF_WIDTH = SC_HALF_WIDTH;
	enumSC.HALF_HEIGHT = SC_HALF_HEIGHT;
	enumSC.HALF_SIZE = SC_HALF_SIZE;
	enumSC.DOUBLE_WIDTH = SC_DOUBLE_WIDTH;
	enumSC.DOUBLE_HEIGHT = SC_DOUBLE_HEIGHT;
	enumSC.DOUBLE_SIZE = SC_DOUBLE_SIZE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSTRING----------------------
	enumSTRING.NG = STRING_NG;
	enumSTRING.BOTTOM_CENTER = STRING_BOTTOM_CENTER;
	enumSTRING.TOP_CENTER = STRING_TOP_CENTER;
	enumSTRING.CENTER_CENTER = STRING_CENTER_CENTER;
	enumSTRING.TOP_LEFT = STRING_TOP_LEFT;
	enumSTRING.TOP_RIGHT = STRING_TOP_RIGHT;
	enumSTRING.BOTTOM_LEFT = STRING_BOTTOM_LEFT;
	enumSTRING.BOTTOM_RIGHT = STRING_BOTTOM_RIGHT;
	enumSTRING.DOWN_DAMAGE_BAR = STRING_DOWN_DAMAGE_BAR;
	enumSTRING.DOWN_COLD_BAR = STRING_DOWN_COLD_BAR;
	enumSTRING.DOWN_LEFT_BARS = STRING_DOWN_LEFT_BARS;
	enumSTRING.DOWN_RIGHT_BARS = STRING_DOWN_RIGHT_BARS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumADD----------------------
	enumADD.FLAME = ADD_FLAME;
	enumADD.SMOKE = ADD_SMOKE;
	enumADD.BLOOD = ADD_BLOOD;
	enumADD.MIST = ADD_MIST;
	enumADD.LIGHT_FLAT = ADD_LIGHT_FLAT;
	enumADD.LIGHT_BLINK = ADD_LIGHT_BLINK;
	enumADD.LIGHT_SPOT = ADD_LIGHT_SPOT;
	enumADD.LIGHT_GLOVE = ADD_LIGHT_GLOVE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumENV----------------------
	enumENV.NO_BLOCK_IN_FRONT = ENV_NO_BLOCK_IN_FRONT;
	enumENV.HANG_WITH_FEET = ENV_HANG_WITH_FEET;
	enumENV.HOLE_FLOOR_IN_FRONT = ENV_HOLE_FLOOR_IN_FRONT;
	enumENV.MONKEY_CEILING = ENV_MONKEY_CEILING;
	enumENV.CLIMB_WALL_IN_FRONT = ENV_CLIMB_WALL_IN_FRONT;
	enumENV.CLIMB_WALL_AT_RIGHT = ENV_CLIMB_WALL_AT_RIGHT;
	enumENV.CLIMB_WALL_AT_LEFT = ENV_CLIMB_WALL_AT_LEFT;
	enumENV.HOLE_IN_FRONT_CEILING_CLIMB = ENV_HOLE_IN_FRONT_CEILING_CLIMB;
	enumENV.HOLE_BACK_CEILING_CLIMB = ENV_HOLE_BACK_CEILING_CLIMB;
	enumENV.NO_BLOCK_AT_RIGHT = ENV_NO_BLOCK_AT_RIGHT;
	enumENV.NO_BLOCK_AT_LEFT = ENV_NO_BLOCK_AT_LEFT;
	enumENV.HOLE_FLOOR_AT_RIGHT = ENV_HOLE_FLOOR_AT_RIGHT;
	enumENV.HOLE_FLOOR_AT_LEFT = ENV_HOLE_FLOOR_AT_LEFT;
	enumENV.HOLE_FLOOR_BACK = ENV_HOLE_FLOOR_BACK;
	enumENV.NO_BLOCK_BACK = ENV_NO_BLOCK_BACK;
	enumENV.CLIMB_WALL_BACK = ENV_CLIMB_WALL_BACK;
	enumENV.SUPPORT_IN_FRONT_WALL = ENV_SUPPORT_IN_FRONT_WALL;
	enumENV.SUPPORT_IN_RIGHT_WALL = ENV_SUPPORT_IN_RIGHT_WALL;
	enumENV.SUPPORT_IN_LEFT_WALL = ENV_SUPPORT_IN_LEFT_WALL;
	enumENV.SUPPORT_IN_BACK_WALL = ENV_SUPPORT_IN_BACK_WALL;
	enumENV.ITEM_EXTRA_IN_FRONT = ENV_ITEM_EXTRA_IN_FRONT;
	enumENV.ITEM_EXTRA_OVER = ENV_ITEM_EXTRA_OVER;
	enumENV.ITEM_EXTRA_UNDER = ENV_ITEM_EXTRA_UNDER;
	enumENV.MULT_CONDITION = ENV_MULT_CONDITION;
	enumENV.HANG_LEFT_IN_CORNER = ENV_HANG_LEFT_IN_CORNER;
	enumENV.HANG_LEFT_OUT_CORNER = ENV_HANG_LEFT_OUT_CORNER;
	enumENV.HANG_RIGHT_IN_CORNER = ENV_HANG_RIGHT_IN_CORNER;
	enumENV.HANG_RIGHT_OUT_CORNER = ENV_HANG_RIGHT_OUT_CORNER;
	enumENV.HANG_LEFT_SPACE = ENV_HANG_LEFT_SPACE;
	enumENV.HANG_RIGHT_SPACE = ENV_HANG_RIGHT_SPACE;
	enumENV.DISTANCE_CEILING = ENV_DISTANCE_CEILING;
	enumENV.CLIMB_LEFT_IN_CORNER = ENV_CLIMB_LEFT_IN_CORNER;
	enumENV.CLIMB_LEFT_OUT_CORNER = ENV_CLIMB_LEFT_OUT_CORNER;
	enumENV.CLIMB_RIGHT_IN_CORNER = ENV_CLIMB_RIGHT_IN_CORNER;
	enumENV.CLIMB_RIGHT_OUT_CORNER = ENV_CLIMB_RIGHT_OUT_CORNER;
	enumENV.CLIMB_LEFT_SPACE = ENV_CLIMB_LEFT_SPACE;
	enumENV.CLIMB_RIGHT_SPACE = ENV_CLIMB_RIGHT_SPACE;
	enumENV.MULT_OR_CONDITION = ENV_MULT_OR_CONDITION;
	enumENV.DISTANCE_FLOOR = ENV_DISTANCE_FLOOR;
	enumENV.FRAME_NUMBER = ENV_FRAME_NUMBER;
	enumENV.VERTICAL_ORIENT = ENV_VERTICAL_ORIENT;
	enumENV.ON_VEHICLE = ENV_ON_VEHICLE;
	enumENV.FREE_HANDS = ENV_FREE_HANDS;
	enumENV.UNDERWATER = ENV_UNDERWATER;
	enumENV.FLOATING = ENV_FLOATING;
	enumENV.ONLAND = ENV_ONLAND;
	enumENV.IS_STILL = ENV_IS_STILL;
	enumENV.ANIM_COMPLETE = ENV_ANIM_COMPLETE;
	enumENV.FLYING_UP = ENV_FLYING_UP;
	enumENV.FLYING_DOWN = ENV_FLYING_DOWN;
	enumENV.WALL_HOLE_IN_FRONT = ENV_WALL_HOLE_IN_FRONT;
	enumENV.IN_LEFT_SIDE_SECTOR = ENV_IN_LEFT_SIDE_SECTOR;
	enumENV.IN_RIGHT_SIDE_SECTOR = ENV_IN_RIGHT_SIDE_SECTOR;
	enumENV.ITEM_EXTRA_AT_LEFT = ENV_ITEM_EXTRA_AT_LEFT;
	enumENV.ITEM_EXTRA_AT_RIGHT = ENV_ITEM_EXTRA_AT_RIGHT;
	enumENV.ITEM_TEST_POSITION = ENV_ITEM_TEST_POSITION;
	enumENV.HOLD_EXTRA_ITEM_IN_HANDS = ENV_HOLD_EXTRA_ITEM_IN_HANDS;
	enumENV.CONDITION_TRIGGER_GROUP = ENV_CONDITION_TRIGGER_GROUP;
	enumENV.ROOM_IS = ENV_ROOM_IS;
	enumENV.PLAYER_IS_SLEEPING = ENV_PLAYER_IS_SLEEPING;
	enumENV.PLAYER_WOKE_UP = ENV_PLAYER_WOKE_UP;
	enumENV.DISTANCE_NORTH_WALL = ENV_DISTANCE_NORTH_WALL;
	enumENV.DISTANCE_SOUTH_WALL = ENV_DISTANCE_SOUTH_WALL;
	enumENV.DISTANCE_EAST_WALL = ENV_DISTANCE_EAST_WALL;
	enumENV.DISTANCE_WEST_WALL = ENV_DISTANCE_WEST_WALL;
	enumENV.LARA_IN_MICRO_STRIP = ENV_LARA_IN_MICRO_STRIP;
	enumENV.NO_BOX_IN_FRONT = ENV_NO_BOX_IN_FRONT;
	enumENV.NO_BOX_AT_LEFT = ENV_NO_BOX_AT_LEFT;
	enumENV.NO_BOX_AT_RIGHT = ENV_NO_BOX_AT_RIGHT;
	enumENV.NO_BOX_BACK = ENV_NO_BOX_BACK;
	enumENV.ENEMY_SEE_LARA = ENV_ENEMY_SEE_LARA;
	enumENV.FRAME_RANGE = ENV_FRAME_RANGE;
	enumENV.NON_TRUE = ENV_NON_TRUE;
	enumENV.POS_LEFT_CORNER = ENV_POS_LEFT_CORNER;
	enumENV.POS_RIGHT_CORNER = ENV_POS_RIGHT_CORNER;
	enumENV.POS_CENTRAL = ENV_POS_CENTRAL;
	enumENV.POS_HORTOGONAL = ENV_POS_HORTOGONAL;
	enumENV.POS_IN_THE_MIDDLE = ENV_POS_IN_THE_MIDDLE;
	enumENV.POS_STRIP_3 = ENV_POS_STRIP_3;
	enumENV.POS_STRIP_2 = ENV_POS_STRIP_2;
	enumENV.POS_STRIP_1 = ENV_POS_STRIP_1;
	enumENV.MASK_CONDITION = ENV_MASK_CONDITION;
	enumENV.MASK_FLAGS = ENV_MASK_FLAGS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCBT----------------------
	enumCBT.FIRST = CBT_FIRST;
	enumCBT.AFTER = CBT_AFTER;
	enumCBT.REPLACE = CBT_REPLACE;
	enumCBT.ASM = CBT_ASM;
	enumCBT.PRESENT = CBT_PRESENT;
	enumCBT.LOOPED = CBT_LOOPED;
	enumCBT.ANY = CBT_ANY;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFAN----------------------
	enumFAN.MASK_FPS_UV = FAN_MASK_FPS_UV;
	enumFAN.MASK_UVROTATE = FAN_MASK_UVROTATE;
	enumFAN.MASK_DELAY = FAN_MASK_DELAY;
	enumFAN.MASK_ANIM = FAN_MASK_ANIM;
	enumFAN.FRAMES = FAN_FRAMES;
	enumFAN.P_FRAMES = FAN_P_FRAMES;
	enumFAN.FULL_ROTATE = FAN_FULL_ROTATE;
	enumFAN.RIVER_ROTATE = FAN_RIVER_ROTATE;
	enumFAN.HALF_ROTATE = FAN_HALF_ROTATE;
	enumFAN.ANY_ROTATE = FAN_ANY_ROTATE;
	enumFAN.SET_FREE_HANDS = FAN_SET_FREE_HANDS;
	enumFAN.START_FROM_EXTRA_FRAME = FAN_START_FROM_EXTRA_FRAME;
	enumFAN.SET_NEUTRAL_STATE_ID = FAN_SET_NEUTRAL_STATE_ID;
	enumFAN.KEYS_AS_SCANCODE = FAN_KEYS_AS_SCANCODE;
	enumFAN.DISABLE_PUSH_AWAY = FAN_DISABLE_PUSH_AWAY;
	enumFAN.KEEP_NEXT_STATEID = FAN_KEEP_NEXT_STATEID;
	enumFAN.ENABLE_GRAVITY = FAN_ENABLE_GRAVITY;
	enumFAN.DISABLE_GRAVITY = FAN_DISABLE_GRAVITY;
	enumFAN.PERFORM_TRIGGER_GROUP = FAN_PERFORM_TRIGGER_GROUP;
	enumFAN.SET_FREE_HANDS_TEMP = FAN_SET_FREE_HANDS_TEMP;
	enumFAN.SET_BUSY_HANDS = FAN_SET_BUSY_HANDS;
	enumFAN.ALIGN_TO_ENV_POS = FAN_ALIGN_TO_ENV_POS;
	enumFAN.SET_ADDEFFECT = FAN_SET_ADDEFFECT;
	enumFAN.RANDOM = FAN_RANDOM;
	enumFAN.SET_LARA_PLACE = FAN_SET_LARA_PLACE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFLH----------------------
	enumFLH.ALMOST_FREE_HANDS = FLH_ALMOST_FREE_HANDS;
	enumFLH.IS_GRABBING = FLH_IS_GRABBING;
	enumFLH.IS_EXTRACTING = FLH_IS_EXTRACTING;
	enumFLH.IS_THROWING = FLH_IS_THROWING;
	enumFLH.HOLDS_ITEM = FLH_HOLDS_ITEM;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCMD----------------------
	enumCMD.ALL = CMD_ALL;
	enumCMD.UP = CMD_UP;
	enumCMD.DOWN = CMD_DOWN;
	enumCMD.LEFT = CMD_LEFT;
	enumCMD.RIGHT = CMD_RIGHT;
	enumCMD.DUCK = CMD_DUCK;
	enumCMD.DASH = CMD_DASH;
	enumCMD.WALK = CMD_WALK;
	enumCMD.JUMP = CMD_JUMP;
	enumCMD.ACTION = CMD_ACTION;
	enumCMD.DRAW_WEAPON = CMD_DRAW_WEAPON;
	enumCMD.USE_FLARE = CMD_USE_FLARE;
	enumCMD.LOOK = CMD_LOOK;
	enumCMD.ROLL = CMD_ROLL;
	enumCMD.INVENTORY = CMD_INVENTORY;
	enumCMD.STEP_LEFT = CMD_STEP_LEFT;
	enumCMD.STEP_RIGHT = CMD_STEP_RIGHT;
	enumCMD.PAUSE = CMD_PAUSE;
	enumCMD.SAVE_GAME = CMD_SAVE_GAME;
	enumCMD.LOAD_GAME = CMD_LOAD_GAME;
	enumCMD.WEAPON_KEYS = CMD_WEAPON_KEYS;
	enumCMD.ENTER = CMD_ENTER;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSRV----------------------
	enumSRV.PERFORM_FLIPEFFECT = SRV_PERFORM_FLIPEFFECT;
	enumSRV.PERFORM_ACTION = SRV_PERFORM_ACTION;
	enumSRV.PERFORM_CONDITION = SRV_PERFORM_CONDITION;
	enumSRV.PERFORM_TRIGGERGROUP_ID = SRV_PERFORM_TRIGGERGROUP_ID;
	enumSRV.PERFORM_EXPORTED_TRIGGER = SRV_PERFORM_EXPORTED_TRIGGER;
	enumSRV.CREATE_TRIGGERGROUP = SRV_CREATE_TRIGGERGROUP;
	enumSRV.CREATE_ANIMATION = SRV_CREATE_ANIMATION;
	enumSRV.CREATE_ANIMATIONSLOT = SRV_CREATE_ANIMATIONSLOT;
	enumSRV.CREATE_MULTENVCONDITION = SRV_CREATE_MULTENVCONDITION;
	enumSRV.CREATE_TESTPOSITION = SRV_CREATE_TESTPOSITION;
	enumSRV.CREATE_ADDEFFECT = SRV_CREATE_ADDEFFECT;
	enumSRV.SetReservedDataZone = SRV_SetReservedDataZone;
	enumSRV.F_ProporzioneDistanza = SRV_F_ProporzioneDistanza;
	enumSRV.F_EseguiTriggerGroup = SRV_F_EseguiTriggerGroup;
	enumSRV.F_DetectedGlobalTriggerEvent = SRV_F_DetectedGlobalTriggerEvent;
	enumSRV.F_InviaErroreLog = SRV_F_InviaErroreLog;
	enumSRV.CREATE_PARAM_COMMAND = SRV_CREATE_PARAM_COMMAND;
	enumSRV.F_TestEnvCondition = SRV_F_TestEnvCondition;
	enumSRV.F_IsBoxSettore = SRV_F_IsBoxSettore;
	enumSRV.F_VerificaTestPosition = SRV_F_VerificaTestPosition;
	enumSRV.F_CollideItemConCustom = SRV_F_CollideItemConCustom;
	enumSRV.F_IsCollisioneConItems = SRV_F_IsCollisioneConItems;
	enumSRV.F_InviaLog = SRV_F_InviaLog;
	enumSRV.F_EseguiAnimNemico = SRV_F_EseguiAnimNemico;
	enumSRV.F_CreateAIRecord = SRV_F_CreateAIRecord;
	enumSRV.F_DeleteAIRecord = SRV_F_DeleteAIRecord;
	enumSRV.F_CreateNewMoveable = SRV_F_CreateNewMoveable;
	enumSRV.F_DeleteNewMoveable = SRV_F_DeleteNewMoveable;
	enumSRV.CREATE_COLOR_RGB_COMMAND = SRV_CREATE_COLOR_RGB_COMMAND;
	enumSRV.DeleteParamCommand = SRV_DeleteParamCommand;
	enumSRV.DeleteTriggerGroup = SRV_DeleteTriggerGroup;
	enumSRV.DeleteColorRgb = SRV_DeleteColorRgb;
	enumSRV.DeleteMultEnvCondition = SRV_DeleteMultEnvCondition;
	enumSRV.DeleteTestPosition = SRV_DeleteTestPosition;
	enumSRV.DeleteAddEffect = SRV_DeleteAddEffect;
	enumSRV.F_DisableSaving = SRV_F_DisableSaving;
	enumSRV.F_AggiungiItemMosso = SRV_F_AggiungiItemMosso;
	enumSRV.F_CheckForStartMovePushable = SRV_F_CheckForStartMovePushable;
	enumSRV.F_CheckForEndMovePushable = SRV_F_CheckForEndMovePushable;
	enumSRV.F_ExplosionOnVehicle = SRV_F_ExplosionOnVehicle;
	enumSRV.F_ConvertMicroUnits = SRV_F_ConvertMicroUnits;
	enumSRV.F_AllocateImage = SRV_F_AllocateImage;
	enumSRV.F_FreeImage = SRV_F_FreeImage;
	enumSRV.F_AllocateTombHdc = SRV_F_AllocateTombHdc;
	enumSRV.F_FreeTombHdc = SRV_F_FreeTombHdc;
	enumSRV.F_DrawSprite2D = SRV_F_DrawSprite2D;
	enumSRV.F_DrawMesh3D = SRV_F_DrawMesh3D;
	enumSRV.F_DrawObject2D = SRV_F_DrawObject2D;
	enumSRV.F_PrintText = SRV_F_PrintText;
	enumSRV.F_ReadDxInput = SRV_F_ReadDxInput;
	enumSRV.F_SuspendAudioTrack = SRV_F_SuspendAudioTrack;
	enumSRV.F_ResumeAudioTrack = SRV_F_ResumeAudioTrack;
	enumSRV.F_CreateWindowsFont = SRV_F_CreateWindowsFont;
	enumSRV.F_FreeWindowsFont = SRV_F_FreeWindowsFont;
	enumSRV.F_ReadInputBox = SRV_F_ReadInputBox;
	enumSRV.F_ReadNumVariable = SRV_F_ReadNumVariable;
	enumSRV.F_WriteNumVariable = SRV_F_WriteNumVariable;
	enumSRV.F_ReadTextVariable = SRV_F_ReadTextVariable;
	enumSRV.F_WriteTextVariable = SRV_F_WriteTextVariable;
	enumSRV.F_ReadMemVariable = SRV_F_ReadMemVariable;
	enumSRV.F_WriteMemVariable = SRV_F_WriteMemVariable;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLEV----------------------
	enumSLEV.YOUNG_LARA = SLEV_YOUNG_LARA;
	enumSLEV.WEATHER = SLEV_WEATHER;
	enumSLEV.HORIZON = SLEV_HORIZON;
	enumSLEV.LAYER1 = SLEV_LAYER1;
	enumSLEV.LAYER2 = SLEV_LAYER2;
	enumSLEV.STAR_FIELD = SLEV_STAR_FIELD;
	enumSLEV.LIGHTNING = SLEV_LIGHTNING;
	enumSLEV.TRAIN = SLEV_TRAIN;
	enumSLEV.PULSE = SLEV_PULSE;
	enumSLEV.COL_ADD_HORIZON = SLEV_COL_ADD_HORIZON;
	enumSLEV.RESET_HUB = SLEV_RESET_HUB;
	enumSLEV.LENS_FLARE = SLEV_LENS_FLARE;
	enumSLEV.TIMER = SLEV_TIMER;
	enumSLEV.MIRROR = SLEV_MIRROR;
	enumSLEV.REMOVE_AMULET = SLEV_REMOVE_AMULET;
	enumSLEV.NO_LEVEL = SLEV_NO_LEVEL;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSMAIN----------------------
	enumSMAIN.FLY_CHEAT = SMAIN_FLY_CHEAT;
	enumSMAIN.LOAD_SAVE = SMAIN_LOAD_SAVE;
	enumSMAIN.TITLE = SMAIN_TITLE;
	enumSMAIN.PLAY_ANY_LEVEL = SMAIN_PLAY_ANY_LEVEL;
	enumSMAIN.DEMO_DISK = SMAIN_DEMO_DISK;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumEDGX----------------------
	enumEDGX.CONCISE_SCRIPT_LOG = EDGX_CONCISE_SCRIPT_LOG;
	enumEDGX.SLOW_MOTION = EDGX_SLOW_MOTION;
	enumEDGX.SWAP_VIEW = EDGX_SWAP_VIEW;
	enumEDGX.LARA_CORD_IN_LOG = EDGX_LARA_CORD_IN_LOG;
	enumEDGX.TRIGGER_TIMING = EDGX_TRIGGER_TIMING;
	enumEDGX.RECORDING_DEMO = EDGX_RECORDING_DEMO;
	enumEDGX.CUTSCENE_LOG = EDGX_CUTSCENE_LOG;
	enumEDGX.ANIMATION_SLOT = EDGX_ANIMATION_SLOT;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumDGX----------------------
	enumDGX.LARA = DGX_LARA;
	enumDGX.ANIMATION = DGX_ANIMATION;
	enumDGX.SFX_SOUNDS = DGX_SFX_SOUNDS;
	enumDGX.FAR_VIEW = DGX_FAR_VIEW;
	enumDGX.AUDIO_TRACKS = DGX_AUDIO_TRACKS;
	enumDGX.CHEATS = DGX_CHEATS;
	enumDGX.FOG = DGX_FOG;
	enumDGX.COMMON_VARIABLES = DGX_COMMON_VARIABLES;
	enumDGX.STORE_VARIABLES = DGX_STORE_VARIABLES;
	enumDGX.FLYBY = DGX_FLYBY;
	enumDGX.TEXT_VARIABLES = DGX_TEXT_VARIABLES;
	enumDGX.LOG_SCRIPT_COMMANDS = DGX_LOG_SCRIPT_COMMANDS;
	enumDGX.WEAPON_ANIMATION = DGX_WEAPON_ANIMATION;
	enumDGX.ADJUSTMENT_MODE = DGX_ADJUSTMENT_MODE;
	enumDGX.FPS = DGX_FPS;
	enumDGX.ERRORS = DGX_ERRORS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFROOM----------------------
	enumFROOM.COLD = FROOM_COLD;
	enumFROOM.RAIN = FROOM_RAIN;
	enumFROOM.SNOW = FROOM_SNOW;
	enumFROOM.REFLECTION = FROOM_REFLECTION;
	enumFROOM.MIST = FROOM_MIST;
	enumFROOM.NON_LENS_FLARE = FROOM_NON_LENS_FLARE;
	enumFROOM.MISTERY = FROOM_MISTERY;
	enumFROOM.OUTSIDE = FROOM_OUTSIDE;
	enumFROOM.DAMAGE = FROOM_DAMAGE;
	enumFROOM.HORIZON = FROOM_HORIZON;
	enumFROOM.QUICKSAND = FROOM_QUICKSAND;
	enumFROOM.IS_FLIPROOM = FROOM_IS_FLIPROOM;
	enumFROOM.WATER = FROOM_WATER;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFIND----------------------
	enumFIND.ITEM = FIND_ITEM;
	enumFIND.STATIC = FIND_STATIC;
	enumFIND.AI = FIND_AI;
	enumFIND.LIGHT = FIND_LIGHT;
	enumFIND.CAMERA_FIXED = FIND_CAMERA_FIXED;
	enumFIND.CAMERA_FLY = FIND_CAMERA_FLY;
	enumFIND.ITEMS_NEARBY = FIND_ITEMS_NEARBY;
	enumFIND.ITEMS_SECTOR = FIND_ITEMS_SECTOR;
	enumFIND.STATICS_NEARBY = FIND_STATICS_NEARBY;
	enumFIND.STATICS_SECTOR = FIND_STATICS_SECTOR;
	enumFIND.ENEMY_COMMAND = FIND_ENEMY_COMMAND;
	enumFIND.IMAGE_COMMAND = FIND_IMAGE_COMMAND;
	enumFIND.WINDOWS_FONT = FIND_WINDOWS_FONT;
	enumFIND.DIAGNOSTIC = FIND_DIAGNOSTIC;
	enumFIND.PROGR_ACTION_TRNG = FIND_PROGR_ACTION_TRNG;
	enumFIND.PROGR_ACTION_MINE = FIND_PROGR_ACTION_MINE;
	enumFIND.ASSIGN_SLOT_MINE = FIND_ASSIGN_SLOT_MINE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSSLOT----------------------
	enumSSLOT.PLANT0 = SSLOT_PLANT0;
	enumSSLOT.PLANT1 = SSLOT_PLANT1;
	enumSSLOT.PLANT2 = SSLOT_PLANT2;
	enumSSLOT.PLANT3 = SSLOT_PLANT3;
	enumSSLOT.PLANT4 = SSLOT_PLANT4;
	enumSSLOT.PLANT5 = SSLOT_PLANT5;
	enumSSLOT.PLANT6 = SSLOT_PLANT6;
	enumSSLOT.PLANT7 = SSLOT_PLANT7;
	enumSSLOT.PLANT8 = SSLOT_PLANT8;
	enumSSLOT.PLANT9 = SSLOT_PLANT9;
	enumSSLOT.FURNITURE0 = SSLOT_FURNITURE0;
	enumSSLOT.FURNITURE1 = SSLOT_FURNITURE1;
	enumSSLOT.FURNITURE2 = SSLOT_FURNITURE2;
	enumSSLOT.FURNITURE3 = SSLOT_FURNITURE3;
	enumSSLOT.FURNITURE4 = SSLOT_FURNITURE4;
	enumSSLOT.FURNITURE5 = SSLOT_FURNITURE5;
	enumSSLOT.FURNITURE6 = SSLOT_FURNITURE6;
	enumSSLOT.FURNITURE7 = SSLOT_FURNITURE7;
	enumSSLOT.FURNITURE8 = SSLOT_FURNITURE8;
	enumSSLOT.FURNITURE9 = SSLOT_FURNITURE9;
	enumSSLOT.ROCK0 = SSLOT_ROCK0;
	enumSSLOT.ROCK1 = SSLOT_ROCK1;
	enumSSLOT.ROCK2 = SSLOT_ROCK2;
	enumSSLOT.ROCK3 = SSLOT_ROCK3;
	enumSSLOT.ROCK4 = SSLOT_ROCK4;
	enumSSLOT.ROCK5 = SSLOT_ROCK5;
	enumSSLOT.ROCK6 = SSLOT_ROCK6;
	enumSSLOT.ROCK7 = SSLOT_ROCK7;
	enumSSLOT.ROCK8 = SSLOT_ROCK8;
	enumSSLOT.ROCK9 = SSLOT_ROCK9;
	enumSSLOT.ARCHITECTURE0 = SSLOT_ARCHITECTURE0;
	enumSSLOT.ARCHITECTURE1 = SSLOT_ARCHITECTURE1;
	enumSSLOT.ARCHITECTURE2 = SSLOT_ARCHITECTURE2;
	enumSSLOT.ARCHITECTURE3 = SSLOT_ARCHITECTURE3;
	enumSSLOT.ARCHITECTURE4 = SSLOT_ARCHITECTURE4;
	enumSSLOT.ARCHITECTURE5 = SSLOT_ARCHITECTURE5;
	enumSSLOT.ARCHITECTURE6 = SSLOT_ARCHITECTURE6;
	enumSSLOT.ARCHITECTURE7 = SSLOT_ARCHITECTURE7;
	enumSSLOT.ARCHITECTURE8 = SSLOT_ARCHITECTURE8;
	enumSSLOT.ARCHITECTURE9 = SSLOT_ARCHITECTURE9;
	enumSSLOT.DEBRIS0 = SSLOT_DEBRIS0;
	enumSSLOT.DEBRIS1 = SSLOT_DEBRIS1;
	enumSSLOT.DEBRIS2 = SSLOT_DEBRIS2;
	enumSSLOT.DEBRIS3 = SSLOT_DEBRIS3;
	enumSSLOT.DEBRIS4 = SSLOT_DEBRIS4;
	enumSSLOT.DEBRIS5 = SSLOT_DEBRIS5;
	enumSSLOT.DEBRIS6 = SSLOT_DEBRIS6;
	enumSSLOT.DEBRIS7 = SSLOT_DEBRIS7;
	enumSSLOT.DEBRIS8 = SSLOT_DEBRIS8;
	enumSSLOT.DEBRIS9 = SSLOT_DEBRIS9;
	enumSSLOT.SHATTER0 = SSLOT_SHATTER0;
	enumSSLOT.SHATTER1 = SSLOT_SHATTER1;
	enumSSLOT.SHATTER2 = SSLOT_SHATTER2;
	enumSSLOT.SHATTER3 = SSLOT_SHATTER3;
	enumSSLOT.SHATTER4 = SSLOT_SHATTER4;
	enumSSLOT.SHATTER5 = SSLOT_SHATTER5;
	enumSSLOT.SHATTER6 = SSLOT_SHATTER6;
	enumSSLOT.SHATTER7 = SSLOT_SHATTER7;
	enumSSLOT.SHATTER8 = SSLOT_SHATTER8;
	enumSSLOT.SHATTER9 = SSLOT_SHATTER9;
	enumSSLOT.EXTRA00 = SSLOT_EXTRA00;
	enumSSLOT.EXTRA01 = SSLOT_EXTRA01;
	enumSSLOT.EXTRA02 = SSLOT_EXTRA02;
	enumSSLOT.EXTRA03 = SSLOT_EXTRA03;
	enumSSLOT.EXTRA04 = SSLOT_EXTRA04;
	enumSSLOT.EXTRA05 = SSLOT_EXTRA05;
	enumSSLOT.EXTRA06 = SSLOT_EXTRA06;
	enumSSLOT.EXTRA07 = SSLOT_EXTRA07;
	enumSSLOT.EXTRA08 = SSLOT_EXTRA08;
	enumSSLOT.EXTRA09 = SSLOT_EXTRA09;
	enumSSLOT.EXTRA10 = SSLOT_EXTRA10;
	enumSSLOT.EXTRA11 = SSLOT_EXTRA11;
	enumSSLOT.EXTRA12 = SSLOT_EXTRA12;
	enumSSLOT.EXTRA13 = SSLOT_EXTRA13;
	enumSSLOT.EXTRA14 = SSLOT_EXTRA14;
	enumSSLOT.EXTRA15 = SSLOT_EXTRA15;
	enumSSLOT.EXTRA16 = SSLOT_EXTRA16;
	enumSSLOT.EXTRA17 = SSLOT_EXTRA17;
	enumSSLOT.EXTRA18 = SSLOT_EXTRA18;
	enumSSLOT.EXTRA19 = SSLOT_EXTRA19;
	enumSSLOT.EXTRA20 = SSLOT_EXTRA20;
	enumSSLOT.EXTRA21 = SSLOT_EXTRA21;
	enumSSLOT.EXTRA22 = SSLOT_EXTRA22;
	enumSSLOT.EXTRA23 = SSLOT_EXTRA23;
	enumSSLOT.EXTRA24 = SSLOT_EXTRA24;
	enumSSLOT.EXTRA25 = SSLOT_EXTRA25;
	enumSSLOT.EXTRA26 = SSLOT_EXTRA26;
	enumSSLOT.EXTRA27 = SSLOT_EXTRA27;
	enumSSLOT.EXTRA28 = SSLOT_EXTRA28;
	enumSSLOT.EXTRA29 = SSLOT_EXTRA29;
	enumSSLOT.EXTRA30 = SSLOT_EXTRA30;
	enumSSLOT.EXTRA31 = SSLOT_EXTRA31;
	enumSSLOT.EXTRA32 = SSLOT_EXTRA32;
	enumSSLOT.EXTRA33 = SSLOT_EXTRA33;
	enumSSLOT.EXTRA34 = SSLOT_EXTRA34;
	enumSSLOT.EXTRA35 = SSLOT_EXTRA35;
	enumSSLOT.EXTRA36 = SSLOT_EXTRA36;
	enumSSLOT.EXTRA37 = SSLOT_EXTRA37;
	enumSSLOT.EXTRA38 = SSLOT_EXTRA38;
	enumSSLOT.EXTRA39 = SSLOT_EXTRA39;
	enumSSLOT.EXTRA40 = SSLOT_EXTRA40;
	enumSSLOT.EXTRA41 = SSLOT_EXTRA41;
	enumSSLOT.EXTRA42 = SSLOT_EXTRA42;
	enumSSLOT.EXTRA43 = SSLOT_EXTRA43;
	enumSSLOT.EXTRA44 = SSLOT_EXTRA44;
	enumSSLOT.EXTRA45 = SSLOT_EXTRA45;
	enumSSLOT.EXTRA46 = SSLOT_EXTRA46;
	enumSSLOT.EXTRA47 = SSLOT_EXTRA47;
	enumSSLOT.EXTRA48 = SSLOT_EXTRA48;
	enumSSLOT.EXTRA49 = SSLOT_EXTRA49;
	enumSSLOT.EXTRA50 = SSLOT_EXTRA50;
	enumSSLOT.EXTRA51 = SSLOT_EXTRA51;
	enumSSLOT.EXTRA52 = SSLOT_EXTRA52;
	enumSSLOT.EXTRA53 = SSLOT_EXTRA53;
	enumSSLOT.EXTRA54 = SSLOT_EXTRA54;
	enumSSLOT.EXTRA55 = SSLOT_EXTRA55;
	enumSSLOT.EXTRA56 = SSLOT_EXTRA56;
	enumSSLOT.EXTRA57 = SSLOT_EXTRA57;
	enumSSLOT.EXTRA58 = SSLOT_EXTRA58;
	enumSSLOT.EXTRA59 = SSLOT_EXTRA59;
	enumSSLOT.EXTRA60 = SSLOT_EXTRA60;
	enumSSLOT.EXTRA61 = SSLOT_EXTRA61;
	enumSSLOT.EXTRA62 = SSLOT_EXTRA62;
	enumSSLOT.EXTRA63 = SSLOT_EXTRA63;
	enumSSLOT.EXTRA64 = SSLOT_EXTRA64;
	enumSSLOT.EXTRA65 = SSLOT_EXTRA65;
	enumSSLOT.EXTRA66 = SSLOT_EXTRA66;
	enumSSLOT.EXTRA67 = SSLOT_EXTRA67;
	enumSSLOT.EXTRA68 = SSLOT_EXTRA68;
	enumSSLOT.EXTRA69 = SSLOT_EXTRA69;
	enumSSLOT.EXTRA70 = SSLOT_EXTRA70;
	enumSSLOT.EXTRA71 = SSLOT_EXTRA71;
	enumSSLOT.EXTRA72 = SSLOT_EXTRA72;
	enumSSLOT.EXTRA73 = SSLOT_EXTRA73;
	enumSSLOT.EXTRA74 = SSLOT_EXTRA74;
	enumSSLOT.EXTRA75 = SSLOT_EXTRA75;
	enumSSLOT.EXTRA76 = SSLOT_EXTRA76;
	enumSSLOT.EXTRA77 = SSLOT_EXTRA77;
	enumSSLOT.EXTRA78 = SSLOT_EXTRA78;
	enumSSLOT.EXTRA79 = SSLOT_EXTRA79;
	enumSSLOT.EXTRA80 = SSLOT_EXTRA80;
	enumSSLOT.EXTRA81 = SSLOT_EXTRA81;
	enumSSLOT.EXTRA82 = SSLOT_EXTRA82;
	enumSSLOT.EXTRA83 = SSLOT_EXTRA83;
	enumSSLOT.EXTRA84 = SSLOT_EXTRA84;
	enumSSLOT.EXTRA85 = SSLOT_EXTRA85;
	enumSSLOT.EXTRA86 = SSLOT_EXTRA86;
	enumSSLOT.EXTRA87 = SSLOT_EXTRA87;
	enumSSLOT.EXTRA88 = SSLOT_EXTRA88;
	enumSSLOT.EXTRA89 = SSLOT_EXTRA89;
	enumSSLOT.EXTRA90 = SSLOT_EXTRA90;
	enumSSLOT.EXTRA91 = SSLOT_EXTRA91;
	enumSSLOT.EXTRA92 = SSLOT_EXTRA92;
	enumSSLOT.EXTRA93 = SSLOT_EXTRA93;
	enumSSLOT.EXTRA94 = SSLOT_EXTRA94;
	enumSSLOT.EXTRA95 = SSLOT_EXTRA95;
	enumSSLOT.EXTRA96 = SSLOT_EXTRA96;
	enumSSLOT.EXTRA97 = SSLOT_EXTRA97;
	enumSSLOT.EXTRA98 = SSLOT_EXTRA98;
	enumSSLOT.EXTRA99 = SSLOT_EXTRA99;
	enumSSLOT.NUMBER_STATIC_OBJECTS = SSLOT_NUMBER_STATIC_OBJECTS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFWEAP----------------------
	enumFWEAP.PRESENT = FWEAP_PRESENT;
	enumFWEAP.LASERSIGHT = FWEAP_LASERSIGHT;
	enumFWEAP.AMMO_NORMAL = FWEAP_AMMO_NORMAL;
	enumFWEAP.AMMO_SUPER = FWEAP_AMMO_SUPER;
	enumFWEAP.AMMO_EXPLOSIVE = FWEAP_AMMO_EXPLOSIVE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCBEET----------------------
	enumCBEET.BEETLE_WITH_KEY = CBEET_BEETLE_WITH_KEY;
	enumCBEET.KEY_SINGLE = CBEET_KEY_SINGLE;
	enumCBEET.BEETLE_SINGLE = CBEET_BEETLE_SINGLE;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumWSKIN----------------------
	enumWSKIN.MISSING = WSKIN_MISSING;
	enumWSKIN.EMPTY_WATER_SKIN = WSKIN_EMPTY_WATER_SKIN;
	enumWSKIN.ONE_LITER = WSKIN_ONE_LITER;
	enumWSKIN.THREE_LITERS = WSKIN_THREE_LITERS;
	enumWSKIN.FIVE_LITERS = WSKIN_FIVE_LITERS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCOMBO----------------------
	enumCOMBO.ITEM1_FOR_PUZZLE_1 = COMBO_ITEM1_FOR_PUZZLE_1;
	enumCOMBO.ITEM2_FOR_PUZZLE_1 = COMBO_ITEM2_FOR_PUZZLE_1;
	enumCOMBO.ITEM1_FOR_PUZZLE_2 = COMBO_ITEM1_FOR_PUZZLE_2;
	enumCOMBO.ITEM2_FOR_PUZZLE_2 = COMBO_ITEM2_FOR_PUZZLE_2;
	enumCOMBO.ITEM1_FOR_PUZZLE_3 = COMBO_ITEM1_FOR_PUZZLE_3;
	enumCOMBO.ITEM2_FOR_PUZZLE_3 = COMBO_ITEM2_FOR_PUZZLE_3;
	enumCOMBO.ITEM1_FOR_PUZZLE_4 = COMBO_ITEM1_FOR_PUZZLE_4;
	enumCOMBO.ITEM2_FOR_PUZZLE_4 = COMBO_ITEM2_FOR_PUZZLE_4;
	enumCOMBO.ITEM1_FOR_PUZZLE_5 = COMBO_ITEM1_FOR_PUZZLE_5;
	enumCOMBO.ITEM2_FOR_PUZZLE_5 = COMBO_ITEM2_FOR_PUZZLE_5;
	enumCOMBO.ITEM1_FOR_PUZZLE_6 = COMBO_ITEM1_FOR_PUZZLE_6;
	enumCOMBO.ITEM2_FOR_PUZZLE_6 = COMBO_ITEM2_FOR_PUZZLE_6;
	enumCOMBO.ITEM1_FOR_PUZZLE_7 = COMBO_ITEM1_FOR_PUZZLE_7;
	enumCOMBO.ITEM2_FOR_PUZZLE_7 = COMBO_ITEM2_FOR_PUZZLE_7;
	enumCOMBO.ITEM1_FOR_PUZZLE_8 = COMBO_ITEM1_FOR_PUZZLE_8;
	enumCOMBO.ITEM2_FOR_PUZZLE_8 = COMBO_ITEM2_FOR_PUZZLE_8;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumKCOMBO----------------------
	enumKCOMBO.ITEM1_FOR_KEY_1 = KCOMBO_ITEM1_FOR_KEY_1;
	enumKCOMBO.ITEM2_FOR_KEY_1 = KCOMBO_ITEM2_FOR_KEY_1;
	enumKCOMBO.ITEM1_FOR_KEY_2 = KCOMBO_ITEM1_FOR_KEY_2;
	enumKCOMBO.ITEM2_FOR_KEY_2 = KCOMBO_ITEM2_FOR_KEY_2;
	enumKCOMBO.ITEM1_FOR_KEY_3 = KCOMBO_ITEM1_FOR_KEY_3;
	enumKCOMBO.ITEM2_FOR_KEY_3 = KCOMBO_ITEM2_FOR_KEY_3;
	enumKCOMBO.ITEM1_FOR_KEY_4 = KCOMBO_ITEM1_FOR_KEY_4;
	enumKCOMBO.ITEM2_FOR_KEY_4 = KCOMBO_ITEM2_FOR_KEY_4;
	enumKCOMBO.ITEM1_FOR_KEY_5 = KCOMBO_ITEM1_FOR_KEY_5;
	enumKCOMBO.ITEM2_FOR_KEY_5 = KCOMBO_ITEM2_FOR_KEY_5;
	enumKCOMBO.ITEM1_FOR_KEY_6 = KCOMBO_ITEM1_FOR_KEY_6;
	enumKCOMBO.ITEM2_FOR_KEY_6 = KCOMBO_ITEM2_FOR_KEY_6;
	enumKCOMBO.ITEM1_FOR_KEY_7 = KCOMBO_ITEM1_FOR_KEY_7;
	enumKCOMBO.ITEM2_FOR_KEY_7 = KCOMBO_ITEM2_FOR_KEY_7;
	enumKCOMBO.ITEM1_FOR_KEY_8 = KCOMBO_ITEM1_FOR_KEY_8;
	enumKCOMBO.ITEM2_FOR_KEY_8 = KCOMBO_ITEM2_FOR_KEY_8;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumEX16----------------------
	enumEX16.EXIST_1 = EX16_EXIST_1;
	enumEX16.EXIST_2 = EX16_EXIST_2;
	enumEX16.EXIST_3 = EX16_EXIST_3;
	enumEX16.EXIST_4 = EX16_EXIST_4;
	enumEX16.EXIST_5 = EX16_EXIST_5;
	enumEX16.EXIST_6 = EX16_EXIST_6;
	enumEX16.EXIST_7 = EX16_EXIST_7;
	enumEX16.EXIST_8 = EX16_EXIST_8;
	enumEX16.EXIST_9 = EX16_EXIST_9;
	enumEX16.EXIST_10 = EX16_EXIST_10;
	enumEX16.EXIST_11 = EX16_EXIST_11;
	enumEX16.EXIST_12 = EX16_EXIST_12;
	enumEX16.EXIST_13 = EX16_EXIST_13;
	enumEX16.EXIST_14 = EX16_EXIST_14;
	enumEX16.EXIST_15 = EX16_EXIST_15;
	enumEX16.EXIST_16 = EX16_EXIST_16;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPCOMBO----------------------
	enumPCOMBO.ITEM1_FOR_PICKUP_1 = PCOMBO_ITEM1_FOR_PICKUP_1;
	enumPCOMBO.ITEM2_FOR_PICKUP_1 = PCOMBO_ITEM2_FOR_PICKUP_1;
	enumPCOMBO.ITEM1_FOR_PICKUP_2 = PCOMBO_ITEM1_FOR_PICKUP_2;
	enumPCOMBO.ITEM2_FOR_PICKUP_2 = PCOMBO_ITEM2_FOR_PICKUP_2;
	enumPCOMBO.ITEM1_FOR_PICKUP_3 = PCOMBO_ITEM1_FOR_PICKUP_3;
	enumPCOMBO.ITEM2_FOR_PICKUP_3 = PCOMBO_ITEM2_FOR_PICKUP_3;
	enumPCOMBO.ITEM1_FOR_PICKUP_4 = PCOMBO_ITEM1_FOR_PICKUP_4;
	enumPCOMBO.ITEM2_FOR_PICKUP_4 = PCOMBO_ITEM2_FOR_PICKUP_4;
	enumPCOMBO.ITEM1_FOR_PICKUP_5 = PCOMBO_ITEM1_FOR_PICKUP_5;
	enumPCOMBO.ITEM2_FOR_PICKUP_5 = PCOMBO_ITEM2_FOR_PICKUP_5;
	enumPCOMBO.ITEM1_FOR_PICKUP_6 = PCOMBO_ITEM1_FOR_PICKUP_6;
	enumPCOMBO.ITEM2_FOR_PICKUP_6 = PCOMBO_ITEM2_FOR_PICKUP_6;
	enumPCOMBO.ITEM1_FOR_PICKUP_7 = PCOMBO_ITEM1_FOR_PICKUP_7;
	enumPCOMBO.ITEM2_FOR_PICKUP_7 = PCOMBO_ITEM2_FOR_PICKUP_7;
	enumPCOMBO.ITEM1_FOR_PICKUP_8 = PCOMBO_ITEM1_FOR_PICKUP_8;
	enumPCOMBO.ITEM2_FOR_PICKUP_8 = PCOMBO_ITEM2_FOR_PICKUP_8;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumDENV----------------------
	enumDENV.FLAG_FACE2FACE = DENV_FLAG_FACE2FACE;
	enumDENV.FLAG_FACE2BACK = DENV_FLAG_FACE2BACK;
	enumDENV.MASK_DISTANCE = DENV_MASK_DISTANCE;
	enumDENV.MASK_FLAGS = DENV_MASK_FLAGS;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLOPE----------------------
	enumSLOPE.FLAT = SLOPE_FLAT;
	enumSLOPE.GENTLE_SLOPE = SLOPE_GENTLE_SLOPE;
	enumSLOPE.STEEP_SLOPE = SLOPE_STEEP_SLOPE;
	enumSLOPE.GENTLE_CORNER = SLOPE_GENTLE_CORNER;
	enumSLOPE.STEEP_CORNER = SLOPE_STEEP_CORNER;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumORIENT----------------------
	enumORIENT.NORTH = ORIENT_NORTH;
	enumORIENT.SOUTH = ORIENT_SOUTH;
	enumORIENT.EAST = ORIENT_EAST;
	enumORIENT.WEST = ORIENT_WEST;
	enumORIENT.SOUTH_EAST = ORIENT_SOUTH_EAST;
	enumORIENT.NORTH_EAST = ORIENT_NORTH_EAST;
	enumORIENT.SOUTH_WEST = ORIENT_SOUTH_WEST;
	enumORIENT.NORTH_WEST = ORIENT_NORTH_WEST;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFSLOT----------------------
	enumFSLOT.NONE = FSLOT_NONE;
	enumFSLOT.PRESENT = FSLOT_PRESENT;
	enumFSLOT.AI_STANDARD = FSLOT_AI_STANDARD;
	enumFSLOT.CHANGE_POS_ITEM = FSLOT_CHANGE_POS_ITEM;
	enumFSLOT.MOVED_BY_ANIMATIONS = FSLOT_MOVED_BY_ANIMATIONS;
	enumFSLOT.SAVE_ALL_DATA = FSLOT_SAVE_ALL_DATA;
	enumFSLOT.AFFECT_LARA_AT_CONTACT = FSLOT_AFFECT_LARA_AT_CONTACT;
	enumFSLOT.SFX_LOCAL_SOUND = FSLOT_SFX_LOCAL_SOUND;
	enumFSLOT.USE_COLLISION_BOX = FSLOT_USE_COLLISION_BOX;
	enumFSLOT.AMPHIBIOUS_CREATURE = FSLOT_AMPHIBIOUS_CREATURE;
	enumFSLOT.HIT_BUT_NOT_HURT_BY_SHOTGUN = FSLOT_HIT_BUT_NOT_HURT_BY_SHOTGUN;
	enumFSLOT.NO_DAMAGE_FOR_NO_EXPLOSIVE_AMMO = FSLOT_NO_DAMAGE_FOR_NO_EXPLOSIVE_AMMO;
	enumFSLOT.SAVE_MESH_MASK = FSLOT_SAVE_MESH_MASK;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFITEM----------------------
	enumFITEM.NONE = FITEM_NONE;
	enumFITEM.ACTIVE = FITEM_ACTIVE;
	enumFITEM.CREATURE = FITEM_CREATURE;
	enumFITEM.NOT_VISIBLE = FITEM_NOT_VISIBLE;
	enumFITEM.GRAVITY_AFFECTED = FITEM_GRAVITY_AFFECTED;
	enumFITEM.FLAG_10 = FITEM_FLAG_10;
	enumFITEM.ITEM_HAS_BEEN_HIT = FITEM_ITEM_HAS_BEEN_HIT;
	enumFITEM.NOT_YET_ENABLED = FITEM_NOT_YET_ENABLED;
	enumFITEM.KILLED_WITH_EXPLOSION = FITEM_KILLED_WITH_EXPLOSION;
	enumFITEM.POISONED = FITEM_POISONED;
	enumFITEM.AI_GUARD = FITEM_AI_GUARD;
	enumFITEM.AI_AMBUSH = FITEM_AI_AMBUSH;
	enumFITEM.AI_PATROL1 = FITEM_AI_PATROL1;
	enumFITEM.AI_MODIFY = FITEM_AI_MODIFY;
	enumFITEM.AI_FOLLOW = FITEM_AI_FOLLOW;
	enumFITEM.THROWN_AMMO = FITEM_THROWN_AMMO;

//  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumMEMT----------------------
	enumMEMT.SAVEGAME = MEMT_SAVEGAME;
	enumMEMT.CODE = MEMT_CODE;
	enumMEMT.ITEM = MEMT_ITEM;
	enumMEMT.SLOT = MEMT_SLOT;
	enumMEMT.ANIMATION = MEMT_ANIMATION;
	enumMEMT.INVENTORY = MEMT_INVENTORY;


}

// #TAG_END_AUTO_ENUM_STUFF#
//  --------------- end of autoenumerate --------------------------------


// FOR_YOU:
// this is the procedure to call global trng services 
int Service(DWORD SRV_Type, ...)
{
	va_list pArgs;
	
	va_start(pArgs, SRV_Type);
	
	

	return Trng.Service(Trng.IdMyPlugin, SRV_Type, pArgs);
}

short CreateNewMoveable(WORD Slot, DWORD CordX, int CordY, DWORD CordZ, int Room)
{
	return Service(SRV_F_CreateNewMoveable, Slot, CordX, CordY, CordZ, Room);
}

// you can use this function only to delete and object you had created with CreateNewMoveable() function

void DeleteNewMoveable(short Index)
{
	Service(SRV_F_DeleteNewMoveable, Index);
}

// set OcbValue = -1 to get an AI record with an Ocb value different by others
// it returns the ocb value of just created ai object
int CreateAIObject(WORD Slot, DWORD CordX, int CordY, DWORD CordZ, WORD Room, int OcbValue, short Facing)
{
	return Service(SRV_F_CreateAIRecord, Slot, CordX, CordY, CordZ, Room, OcbValue, Facing);

}
// deelete the AI object that you created, with Slot type and OcbValue 
// if you set TestAlls = true, all object with that slot and ocb will be deleted
// if you set TestAlls = false, only the last AI object created with that slot and ocb will be deleted
void DeleteAIObject(WORD Slot, WORD OcbValue, bool TestAlls)
{
	Service(SRV_F_DeleteAIRecord, Slot, OcbValue, TestAlls);

}

void DeleteParamCommand(int ParamType, int IdParam)
{
	Service(SRV_DeleteParamCommand, ParamType, IdParam);

}

void DeleteTriggerGroup(int IdTriggerGroup)
{
	Service(SRV_DeleteTriggerGroup, IdTriggerGroup);
}

void DeleteColorRgb(int IdColorRgb)
{
	Service(SRV_DeleteColorRgb, IdColorRgb);
}

void DeleteMultEnvCondition(int IdMultEnv)
{
	Service(SRV_DeleteMultEnvCondition, IdMultEnv);
}

void DeleteTestPosition(int IdTest)
{
	Service(SRV_DeleteTestPosition, IdTest);
}

void DeleteAddEffect(int IdEffect) 
{
	Service(SRV_DeleteAddEffect,IdEffect);
}
// disable the chance to save the game for FrameDurate (frame units: 1/30th of second)
void DisableSaving(int FrameDurate)
{
	Service(SRV_F_DisableSaving, FrameDurate);
}
// computes the absolute difference betweeen two unsigned values, i.e. the X and Z coordinates
int AbsDiff(DWORD First, DWORD Second)
{
	return (int) abs((int) First - (int) Second);

}

// computes the absolute difference between two signed values, i.e. Y coordinates
int AbsDiffY(int First, int Second)
{

	return abs(First - Second);
}
// compute the absolute distance between two orienting (facing) values
int AbsDiffO(short First, short Second)
{

	short SwapValue;
	WORD WordValue;


	if (First > Second) {
		SwapValue = First;
		First = Second;
		Second = SwapValue;
	}

	// check for problem: first value is negative (very little value) and second positive (very higher value)
	// but really two values are very closed (0x7fff 0x8001)
	if (First < -16384 && Second > 16384) {
		// compute with positive values
		WordValue = (WORD) First;
		return AbsDiffY(WordValue, Second);
	}

	return abs(First-Second);
}

// send to load a text with (optional) variable arguments: use %d  for numbers, and %s for texts
bool SendToLog(char *szFormat, ...)
{
	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMain
	static char MyInternalBuffer[512];

	if (*pTombWind4 == 0) return false;

    va_list pArgs;
    va_start(pArgs, szFormat);
    vsprintf(MyInternalBuffer, szFormat, pArgs);
    va_end(pArgs);

	Service(SRV_F_InviaLog, MyInternalBuffer);
	return true;

}
// this function works like SendToLog() but it will show messages only when you are working with debug version of plugin.
bool LogOnDebug(char *szFormat, ...)
{
	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMain
	static char MyInternalBuffer[512];

	if (Trng.TestDebugMode == false) return false;
	if (*pTombWind4 == 0) return false;

    va_list pArgs;
    va_start(pArgs, szFormat);
    vsprintf(MyInternalBuffer, szFormat, pArgs);
    va_end(pArgs);

	Service(SRV_F_InviaLog, MyInternalBuffer);

	return true;

}

// round floating value to closest integer
int Float2Int(float x) 
{ 
    return (int)(x > 0.0 ? x + 0.5 : x - 0.5); 

} 

// Compute distance in 3d world (x,y,z) between two given point: source and target
int GetDistanceXZY(DWORD SourceX, int SourceY, DWORD SourceZ, DWORD TargetX, int TargetY, DWORD TargetZ)
{
	float DifX, DifZ, DifY;

	DifX = (float) SourceX - (float) TargetX;
	DifZ = (float) SourceZ - (float) TargetZ;
	DifY = (float) SourceY - (float) TargetY;

	return Float2Int((float) sqrt(
			pow(DifX,2) +
			pow(DifZ,2) +
			pow(DifY,2)));

}


// Compute distance in 2d view (x, z) ignoring height (Y coordinates), between two given point: source and target
int GetDistanceXZ(DWORD SourceX, DWORD SourceZ, DWORD TargetX, DWORD TargetZ)
{
	float DifX, DifZ;

	DifX = (float) SourceX - (float) TargetX;
	DifZ = (float) SourceZ - (float) TargetZ;

	return Float2Int((float) sqrt(
			pow(DifX,2) +
			pow(DifZ,2)));

}

// This function is less precise than GetDistanceXZ() and GetDistanceXYZ() but it's faster 
// it returns the max distance on one of three axis (z, x or Y if TestIgnoreY==false)
int GetMaxDistance(DWORD *pSource, DWORD *pTarget, bool TestIgnoreY)
{
	DWORD DifX;
	DWORD DifY;
	DWORD DifZ;
	DWORD MaxDif;

	DifX = AbsDiff(pSource[0], pTarget[0] );
	if (TestIgnoreY==false) {
		DifY = AbsDiff(pSource[1],pTarget[1]);
	}
	DifZ = AbsDiff(pSource[2],pTarget[2]);

	MaxDif= DifX;
	if (TestIgnoreY==false) {
		if (DifY > MaxDif) MaxDif = DifY;
	}
	if (DifZ > MaxDif) MaxDif = DifZ;
	return MaxDif;

}


// if you set NexStateId==-1 it will be used the stateid of animation record you just set as next state id
void ForceAnimationForItem(StrItemTr4 *pItem, int NumAnimation, int NextStateId)
{
	Service(SRV_F_EseguiAnimNemico, pItem, NumAnimation, NextStateId);

}
// print text on tomb raider screen using default (tomb4) printstring function
// parameteres:
// CordX , CordY : pixel coordinates for origin of text
// pText : address of text to print
// FTflags: one or more of enumFT_ values to set size of characters
// FCindex: enumFC_ prefixed color for text
// FTSflags:  one or more enumFTS value to set alignment and blinking
// note: you can use this function only when drawing operations are opened
void PrintText(int CordX, int CordY, char *pText, WORD FTflags, int FCindex, WORD FTSflags)
{
	Service(SRV_F_PrintText, CordX, CordY, pText, FTflags, FCindex, FTSflags);
}

// if you set NexStateId==-1 it will be used the stateid of animation record you just set as next state id
void ForceAnimationForLara(int NumAnimation, int NextStateId)
{
	int StartAnim;
	int IndexAnim;
	StrItemTr4 *pLara;
	StrAnimationTr4 * pAnim;

	pLara = Trng.pGlobTomb4->pAdr->pLara;

	StartAnim= Trng.pGlobTomb4->pAdr->pVetSlot[0].IndexFirstAnim;
	IndexAnim = StartAnim+NumAnimation;

	pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[IndexAnim];


	// if current lara animation is already the same to set: quit
	if (pLara->AnimationNow == IndexAnim) return;

	// verifiy that wished animation existed really
	if (pAnim->FrameSize == 0) {
		SendToLog("ERROR: missing animation number %d for Lara", NumAnimation);
		return;
	}

	pLara->FrameNow = pAnim->FrameStart;
	pLara->StateIdCurrent = pAnim->StateId;
	pLara->StateIdNext = pAnim->StateId;

	if (NextStateId != -1) {
		pLara->StateIdNext = NextStateId;
	}

	pLara->AnimationNow = IndexAnim;
	
	
}




int DistanceProp(int Incremento, int Distanza)
{

	return Service(SRV_F_ProporzioneDistanza, Incremento, Distanza);

}
// FOR_YOU:
// convert an original ngle index (like those typed in the script dat commands)
// to the effective tomb4 index
// this function works only with the indices of moveables
// note: if the NgleIndex is wrong , this function returns -1
int FromNgleIndexToTomb4Index(int NgleIndex)
{
	int i;

	i= Trng.pGlobTomb4->VetRemapObjects[NgleIndex];
#ifdef DEBUG_ON
	if (i == -1) {
		SendToLog("ERROR: the Ngle index %d doesn't correspond to any tomb4 index",
			NgleIndex);
	}
#endif
	
	return i;
}
// if you have two tomb4 indices for static and you wish know the single ngle index for that static
// you can use this function
// WARNING: this function is very slow, you should use it ONLY for debugging in temporary way.
// while when you wish convert double tomb indices to ngle static indeex to use some flipeffect
// you should use the CreateNgleStaticIndex() function that is faster
int FromStaticIndicesToNgleIndex(int RoomIndex, int StaticIndex)
{
	StrCercaStatic *pDouble;
	int i;

	pDouble = &Trng.pGlobTomb4->VetRemapStatics[0];

	for (i=0;i<6000;i++) {
		if (pDouble->IndiceRoom == RoomIndex &&
			pDouble->IndiceStatic == StaticIndex) {
			// found
			return i;
		}
		pDouble++;
	}

	SendToLog("ERROR: cann't find the ngle static index that matched with (room=%d StaticIndex=%d)",
		RoomIndex, StaticIndex);
	return -1;

}
// when you own the tomb4 indices (room and static) of some static and you wish get a single ngle static index
// to pass this value to some trng function (like flipeffect triggers) you can use this function
// NOTE: you cann't have more than one created ngle static index at same time.
int CreateNgleStaticIndex(int RoomIndex, int StaticIndex)
{
	StrCercaStatic *pDouble;
	int NgleStaticIndex;

	NgleStaticIndex=6000;
	pDouble = &Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex];

	pDouble->IndiceRoom = RoomIndex;
	pDouble->IndiceStatic = StaticIndex;

	return NgleStaticIndex;

}
// to call after having moved a moveable item.
// this function will check if the room of the item (with ItemIndex) is different and in the case it will, 
// it will update the room index and the room owner of current item
// If the room has been changed it will return "true"

bool UpdateItemRoom(int ItemIndex)
{
	short NewRoom;
	StrItemTr4 *pItem;
	int Index;

	if (ItemIndex & NGLE_INDEX) {
		Index = ItemIndex & MASK_NGLE_INDEX;
		ItemIndex = FromNgleIndexToTomb4Index(Index);
		if (ItemIndex == -1) return false;
	
	}
	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

	NewRoom = pItem->Room;

	GetFloor(pItem->CordX, pItem->CordY, pItem->CordZ, &NewRoom);
	
	if (NewRoom != pItem->Room) {
		// the room changed
		ItemNewRoom(ItemIndex, NewRoom);
		return true;
	}
	return false;
}

bool CheckPositionAlignment(StrTestPositionCmd *pTestPosition, int ObjectIndex)
{
	int Index;



	if (ObjectIndex & NGLE_INDEX) {
		Index = ObjectIndex & MASK_NGLE_INDEX;
		ObjectIndex = FromNgleIndexToTomb4Index(Index);
	
	}	

	if (ObjectIndex==-1) return false;

	if (Service(SRV_F_VerificaTestPosition, pTestPosition, ObjectIndex) ==0) return false;

	return true;
}

void SignalMovedItem(int IndexItem)
{
	Service(SRV_F_AggiungiItemMosso, IndexItem);

}
// salva dati per animazione di lara in variabile globali
void BackupLara(StrBackupLara *pBack, StrItemTr4 *pOggetto)
{
	DWORD *pCopiaOrientamento = (DWORD *)  0x80DF64; //   ;ZonaSave_FB_CopiaOrientamento

	pBack->CopiaOrientamento = *pCopiaOrientamento;
	pBack->AnimationNow  = pOggetto->AnimationNow;
	pBack->FrameNow  = pOggetto->FrameNow;
	pBack->StateIdCurrent  =pOggetto->StateIdCurrent;
	pBack->StateIdNext  = pOggetto->StateIdNext;
	pBack->LaraRoom = pOggetto->Room;
	pBack->LaraX = pOggetto->CordX;
	pBack->LaraY = pOggetto->CordY;
	pBack->LaraZ = pOggetto->CordZ;
	pBack->Orient = pOggetto->OrientationH;
	pBack->SpeedH = pOggetto->SpeedH;
	pBack->SpeedV = pOggetto->SpeedV;

}

void RestoreLara(StrBackupLara *pBack, StrItemTr4 *pOggetto)
{

	DWORD *pCopiaOrientamento = (DWORD *)  0x80DF64; //   ;ZonaSave_FB_CopiaOrientamento

	*pCopiaOrientamento = pBack->CopiaOrientamento;

	pOggetto->AnimationNow = pBack->AnimationNow;
	pOggetto->FrameNow =pBack->FrameNow;
	pOggetto->StateIdCurrent = pBack->StateIdCurrent;
	pOggetto->StateIdNext =	pBack->StateIdNext;
	pOggetto->Room = pBack->LaraRoom;
	pOggetto->CordX = pBack->LaraX;
	pOggetto->CordY = pBack->LaraY;
	pOggetto->CordZ = pBack->LaraZ;
	pOggetto->OrientationH= pBack->Orient;
	pOggetto->SpeedH=pBack->SpeedH;
	pOggetto->SpeedV = pBack->SpeedV;


}
// to call before moving a moveable. It checks if currnet moveable is a pushable item with collisions
// if it is, it will perform some adjustment to remove special floor collision
// note: when the moving of moveable it has been completed, you should call also the EndMoveItem() function
// to restore further pushable collisions in final position
// if the item was own a pushable with special collisions it will return "true", otherwise "false"
bool StartMoveItem(int ItemIndex)
{
	if (Service(SRV_F_CheckForStartMovePushable, ItemIndex) > 0) return true;
	return false;
}

// to call when you completed the moving of some moveable.
// this function checks if item was a pushable item with special collision and if it was, it will restore collisions
// note: you should have called the StartMoveItem() function, at start of moving of current item
void EndMoveItem(int ItemIndex)
{
	Service(SRV_F_CheckForEndMovePushable, ItemIndex);
}

// to call after CheckPositionAlignment() when it returned true, to align lara ideal position
// AlignLaraAtPosition() function will return true only when the alignment has been completed
bool AlignLaraAtPosition(StrTestPositionCmd *pTestPosition, int ObjectIndex)
{

	StrItemTr4 *pItem;
	StrItemTr4 *pLara;
	StrMovePosition MovePosData;
	short SalvaOrientH;
	StrMovePosition *pMovPos;
	short DifOrientH;
	StrBackupLara SalvaLara;
	int Index;

	if (ObjectIndex & NGLE_INDEX) {
		Index = ObjectIndex & MASK_NGLE_INDEX;
		ObjectIndex = FromNgleIndexToTomb4Index(Index);
	
	}
	Trng.pGlobTomb4->TestFixLaraMovPos=false;
	pLara= Trng.pGlobTomb4->pAdr->pLara;
	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ObjectIndex];

	// farlo in modo immediato se c''e orientamento round in testposition
	if (pTestPosition->Flags & TPOS_ROUND_HORIENT) {
		pItem->CordX = Trng.pGlobTomb4->TestPosXIdeal;
		pItem->CordZ = Trng.pGlobTomb4->TestPosZIdeal;
		pItem->OrientationH = Trng.pGlobTomb4->TestPosOrientIdeal;
	}else {
		// traditionl alignment

		Trng.pGlobTomb4->TestAlignmentInProgress=true;
		*Trng.pGlobTomb4->pAdr->pObjectActive = ObjectIndex;

		pMovPos = &MovePosData;


		pMovPos->RelX  = (pTestPosition->DatiPosition.Distance.MaxX + 
					pTestPosition->DatiPosition.Distance.MinX ) / 2;

		pMovPos->RelY = (pTestPosition->DatiPosition.Distance.MaxY +
					pTestPosition->DatiPosition.Distance.MinY) / 2;

		pMovPos->RelZ = (pTestPosition->DatiPosition.Distance.MaxZ + 
					pTestPosition->DatiPosition.Distance.MinZ ) / 2;

		DifOrientH = (pTestPosition->DatiPosition.Orienting.OrientHMax +
					pTestPosition->DatiPosition.Orienting.OrientHMin) / 2;
		
		if (pTestPosition->Flags & TPOS_TURN_FACING_90) {
			// fixing turning 90 position:
			
			Index = pMovPos->RelX;
			pMovPos->RelX = pMovPos->RelZ;
			pMovPos->RelZ = -Index;
		}


	
		SalvaOrientH = pItem->OrientationH;
		pItem->OrientationH = Trng.pGlobTomb4->TestPosOrientIdeal;
		
		BackupLara(&SalvaLara, pLara);
		if (pTestPosition->Flags & TPOS_FAST_ALIGNMENT) {
			*Trng.pGlobTomb4->pAdr->pFlagsLara |= 0x20;
					
		}

		if (pTestPosition->Flags & TPOS_OPPOSITE_FACING) {
			// attivare correzione di orientamento
			Trng.pGlobTomb4->TestFixLaraMovPos=true;
			Trng.pGlobTomb4->OrientFixLaraMovPos = 
				pItem->OrientationH + DifOrientH;
		}
		if (pTestPosition->Flags & TPOS_TURN_FACING_180) {
			// fixing turning 180
			Trng.pGlobTomb4->TestFixLaraMovPos = true;
			Trng.pGlobTomb4->OrientFixLaraMovPos = pItem->OrientationH + 0x8000;
		}
	
		if (MoveLaraPosition(pMovPos, pItem ,pLara) == false) {

			pItem->OrientationH = SalvaOrientH;


			return false;
		}
		// completed

		RestoreLara(&SalvaLara, pLara);
		Trng.pGlobTomb4->TestFixLaraMovPos=false;
		
		pItem->OrientationH = SalvaOrientH;

		*Trng.pGlobTomb4->pAdr->pObjectActive = -1;
		Trng.pGlobTomb4->TestAlignmentInProgress=false;
		*Trng.pGlobTomb4->pAdr->pFlagsLara &= ~0x20;
		
		

	}
	return true;

}

// FOR_YOU: function to clear a (wide) memory zone
void ClearMemory(void *pZone, DWORD SizeBytes)
{
	memset(pZone, 0, SizeBytes);

}
// verify if box collision of PrimaryItem is colliding with collision box of SecondaryItem +/- tollerance
bool IsCollideWithMoveable(int IndexPrimaryItem, int IndexSecondaryItem, int Tollerance)
{
	StrCustomItem CustomItem;
	StrItemTr4 *pItem;
	int Index;
	StrBoxCollisione *pColl;
	StrItemTr4 *pPrimary;
	StrSlot *pSlot;


	ClearMemory(&COLLIDE.BoxItem, sizeof(StrAbsBoxCollision));
	ClearMemory(&COLLIDE.BoxSecondary, sizeof(StrAbsBoxCollision));


	if (IndexPrimaryItem & NGLE_INDEX) {
		Index = IndexPrimaryItem & MASK_NGLE_INDEX;
		IndexPrimaryItem = FromNgleIndexToTomb4Index(Index);
		if (IndexPrimaryItem==-1) return false;
	}


	if (IndexSecondaryItem & NGLE_INDEX) {
		Index = IndexSecondaryItem & MASK_NGLE_INDEX;
		IndexSecondaryItem = FromNgleIndexToTomb4Index(Index);
		if (IndexSecondaryItem==-1) return false;
	}


	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexSecondaryItem];

	pSlot= &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

	if (pSlot->pProcCollision == NULL) {
		// Collision disabled for it: no collision
		return false;
	}

	if (pSlot->Flags & 0x02) {
		// it is a creature
		// if it has not been yet enabled: no collision
		if (pItem->FlagsMain & 0x20) {
			if ((pItem->FlagsMain & 06)==6) {
				
				return false;
			}
		}
	}
	pPrimary = &Trng.pGlobTomb4->pAdr->pVetItems[IndexPrimaryItem];

	// cut-off, if distance > 3 sectors: no collision
	if (GetMaxDistance(&pItem->CordX, &pPrimary->CordX, false) > 1024*3 ) return false;

	pColl = GetBestFrame(pItem);

	CustomItem.CordX = pItem->CordX;
	CustomItem.CordY = pItem->CordY;
	CustomItem.CordZ = pItem->CordZ;
	CustomItem.hOrient = pItem->OrientationH;
	CustomItem.hOrient = IndexPrimaryItem;
	CustomItem.MaxY = pColl->MaxY;
	CustomItem.MinY = pColl->MinY;
	CustomItem.pBoxRel = pColl;
	CustomItem.Slot = pItem->SlotID;

	if (Service(SRV_F_CollideItemConCustom, pPrimary, &CustomItem, Tollerance) == 0) return false;


	COLLIDE.BoxItem = Trng.pGlobTomb4->pMisc->CollisionLast.BoxItem;
	COLLIDE.BoxSecondary = Trng.pGlobTomb4->pMisc->CollisionLast.BoxSecondary;

	return true;



}
// convert a static ngle index to two tomb indices: the index of room that owns the static, and
// the index of the static
bool FromNgleStaticIndexToTomb4Indices(int IndiceNgle, int *pRoomIndex, int *pStaticIndex)
{
	int RoomIndex;
	int StaticIndex;

	RoomIndex=Trng.pGlobTomb4->VetRemapStatics[IndiceNgle].IndiceRoom;
	StaticIndex= Trng.pGlobTomb4->VetRemapStatics[IndiceNgle].IndiceStatic;

	if (RoomIndex == -1 || StaticIndex==-1) {
		SendToLog("ERROR: static ngle index = %d is not a valid static index", IndiceNgle);
		return false;
	}
	*pRoomIndex = RoomIndex;
	*pStaticIndex = StaticIndex;
	return true;
}


// verify if moveable item with ItemIndex, once moved at (x,y,z) position will collide with some moveable or static item
// result will be saved also in COLLIDE structure
bool IsCollidingWithSomeItem(int ItemIndex, DWORD x, int y, DWORD z, int RoomIndex, 
							 int MaxDistance, int MinLargerSide, int MinHeight, int Tollerance)
{
	bool TestIgnoreLara;
	StrItemTr4 *pItem;
	int Index;

	COLLIDE.ItemIndex=-1;
	COLLIDE.StaticIndex=-1;
	COLLIDE.StaticIndexRoom=-1;

	if (ItemIndex & NGLE_INDEX) {
		Index = ItemIndex & MASK_NGLE_INDEX;
		ItemIndex = FromNgleIndexToTomb4Index(Index);
		if (ItemIndex==-1) return false;
	}

	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

	if (pItem->SlotID==0) {
		TestIgnoreLara=true;
	}else {
		TestIgnoreLara=false;
	}
	
	if (Service(SRV_F_IsCollisioneConItems, pItem, TestIgnoreLara, x,y,z, RoomIndex, 
								MaxDistance, MinLargerSide, MinHeight, Tollerance)==0) return false;

	COLLIDE = Trng.pGlobTomb4->pMisc->CollisionLast;

	return true;

}

bool IsCollideWithStatic(int IndexItem, int StaticIndex, int StaticRoomIndex, int Tollerance) 
{
	StrItemTr4 *pItem;
	StrStaticSlot *pEdit;
	StrBoxCollisione *pCollStatic;
	int Index;
	StrRoomTr4 *pRoom;
	StrCustomItem Custom;
	StrMeshInfo *pStatic;

	ClearMemory(&COLLIDE.BoxItem, sizeof(StrAbsBoxCollision));
	ClearMemory(&COLLIDE.BoxSecondary, sizeof(StrAbsBoxCollision));

	if (StaticIndex & NGLE_INDEX) {
		Index = StaticIndex & MASK_NGLE_INDEX;
		if (FromNgleStaticIndexToTomb4Indices(Index, &StaticRoomIndex, &StaticIndex)==false) return false;
	}

	pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[StaticRoomIndex];

	pStatic = &pRoom->Ptr_StaticMesh[StaticIndex];

	// check if collision are disabled for this static
	if ((pStatic->OCB & OCBS_SCALABLE)==0) {
		if (pStatic->OCB & OCBS_NO_COLLISIONI) return false;
	}

	pEdit = &Trng.pGlobTomb4->pAdr->pVetEditObjects[pStatic->SlotId];
	// if has no collision box: no collision
	if (pEdit->CollisionBox.MinY == 0 &&
		pEdit->CollisionBox.MaxY == 0) {
		return false;
	}

	if (IndexItem & NGLE_INDEX) {
		Index = IndexItem & MASK_NGLE_INDEX;
		IndexItem = FromNgleIndexToTomb4Index(Index);
		if (IndexItem==-1) return false;
	}

	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexItem];

	// if it is not scalable or huge, to do check for distance
	if ((pStatic->OCB & (OCBS_HUGE_COLLISION | OCBS_SCALABLE))==0) {
		// normal static
		if (GetMaxDistance(&pStatic->x, &pItem->CordX, false) >= 3072) {
			// too far: no collision
			return false;
		}
	}

	// perform comparison for collision

	pCollStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[pStatic->SlotId].CollisionBox;
	Custom.CordX = pStatic->x;
	Custom.CordY = pStatic->y;
	Custom.CordZ = pStatic->z;
	Custom.MaxY = pCollStatic->MaxY;
	Custom.MinY = pCollStatic->MinY;
	Custom.hOrient = pStatic->Orient;
	Custom.pBoxRel = pCollStatic;
	Custom.ItemIndex=-1;
	Custom.Slot = -1;

	if (Service(SRV_F_CollideItemConCustom, pItem, &Custom, Tollerance)==0) return false;

	COLLIDE.BoxItem = Trng.pGlobTomb4->pMisc->CollisionLast.BoxItem;
	COLLIDE.BoxSecondary = Trng.pGlobTomb4->pMisc->CollisionLast.BoxSecondary;

	return true;

}
// receice as input the current Orienting (facing) of some item, and returns same orient changed to be aligned to 
// more closed direction to some of 8 perfect directions (4 hortogonals ad 4 diagonal)
// if TestForceHortogonal == true, it will be forced to choose a hortogonal direction as returned value.
// in *pGap variable will be returned the absolute difference between the source orient and the returned orient
// the returned values will be an ORIENT_ mnemonic constant
short GetAlignedOrient(short Orient, bool TestForceHortogonal, int *pGap)
{
	int MinDiff;

	if (TestForceHortogonal==false) {
		// verify if perfect direction more closed is one on diagonal direction
		// try south-east (ngle) direction
		MinDiff = AbsDiffO(Orient, 0x2000);
		if (MinDiff <= 0x1000) {
			*pGap=MinDiff;
			return enumORIENT.SOUTH_EAST;
		}

		// try south-west direction
		MinDiff= AbsDiffO(Orient, 0x6000);
		if (MinDiff <= 0x1000) {
			*pGap =MinDiff;
			return enumORIENT.SOUTH_WEST;
		}


		MinDiff = AbsDiffO(Orient, (short) 0xA000);

		if (MinDiff <= 0x1000) {
			*pGap =MinDiff;
			return enumORIENT.NORTH_WEST;
		}

		// try north-east directio

		MinDiff = AbsDiffO(Orient, (short) 0xE000);
		
		if (MinDiff <= 0x1000) {
			*pGap = MinDiff;
			return enumORIENT.NORTH_EAST;
		}
	}

	// try with hortogonal directions
	// try with east (ngle)
	MinDiff = AbsDiffO(Orient, 0x0000);
	if (MinDiff <= 0x2000) {
		*pGap = MinDiff;
		return enumORIENT.EAST;
	}

	// try with south
	MinDiff = AbsDiffO(Orient, 0x4000);
	if (MinDiff <= 0x2000) {
		*pGap = MinDiff;
		return enumORIENT.SOUTH;
	}
	// try with west

	MinDiff = AbsDiffO(Orient, (short) 0x8000);
	

	if (MinDiff <= 0x2000) {
		*pGap = MinDiff;
		return enumORIENT.WEST;
	}

	// try with north

	MinDiff = AbsDiffO(Orient, (short) 0xc000);
	
	if (MinDiff <= 0x2000) {
		*pGap = MinDiff;
		return enumORIENT.NORTH;
	}
	// it's not possible reaching this point of the code
	SendToLog("ERROR: GetAlignedOrient(): no aligned orient found for source orient 0x%X", Orient);
	*pGap= 0x7000;
	return 9999;

	
}
// given a direction (Facing) and a Distance in game units, it will return in pIncX pIncZ the pair
// of increments to add to (0,0) position to get point at Distance in Facing direction
void GetIncrements(WORD Facing, int *pIncX, int *pIncZ, int Distance)
{
	int IncX, IncZ;
	int Index;
	short * pOrientMatrix = (short *) 0x4B34D0;

	if (Distance == 0) {
		*pIncX = 0;
		*pIncZ = 0;
		return;
	}

	Index = Facing >> 3;
	Index &= 0x1FFE;
	
	IncX = pOrientMatrix[Index] <<	12;
	IncZ = pOrientMatrix[Index+1] << 12;
	IncX = IncX >> 14;
	IncZ = IncZ >> 14;
	// modificarli sulla base di distanza richiesta
	if (Distance != 1024) {
		IncX = DistanceProp(IncX, Distance);
		IncZ = DistanceProp(IncZ, Distance);
	}

	*pIncX = IncX;
	*pIncZ = IncZ;


}

int PerformTriggerGroup(int IdOfTriggerGroup)
{

	return Service(SRV_F_EseguiTriggerGroup, IdOfTriggerGroup);
}
// returns the relative (from 0) frame of current animation for moveable with structure pItem
int GetCurrentFrame(StrItemTr4 *pItem)
{

	DWORD StartFrame;

	StartFrame = Trng.pGlobTomb4->pAdr->pVetAnimations[pItem->AnimationNow].FrameStart;

	return (int) pItem->FrameNow - StartFrame;

}
// change frame number of current animation
void SetCurrentFrame(StrItemTr4 *pItem, int Frame)
{

	DWORD StartFrame;
	
	StartFrame = Trng.pGlobTomb4->pAdr->pVetAnimations[pItem->AnimationNow].FrameStart;
	
	pItem->FrameNow = (WORD) StartFrame + Frame;


}
// change some setting, or all, about chase camera 
// if you don't wish change same value type -1 for that setting
void SetCamera(int Distance, int HOrient, int VOrient, int Speed)
{
	bool TestChange;
	short ValShort;

	if (Speed < 1) Speed=1;

	TestChange=false;

	if (Distance != -1) {
		if (*Trng.pGlobTomb4->pAdr->pSetCameraDistance != Distance) {
			TestChange=true;
			*Trng.pGlobTomb4->pAdr->pSetCameraDistance = Distance;
		}
	}

	if (HOrient != -1) {
		ValShort= (short) HOrient;

		if (*Trng.pGlobTomb4->pAdr->pSetCameraHOrient != ValShort) {
			TestChange=true;
			*Trng.pGlobTomb4->pAdr->pSetCameraHOrient = ValShort;
		}
	}

	if (VOrient != -1) {
		ValShort = (short) VOrient;

		if (*Trng.pGlobTomb4->pAdr->pSetCameraVOrient != ValShort) {
			TestChange=true;
			*Trng.pGlobTomb4->pAdr->pSetCameraVOrient = ValShort;
		}
	}

	if (TestChange==true) {
		*Trng.pGlobTomb4->pAdr->pSetCameraSpeed =(WORD) Speed;
		*Trng.pGlobTomb4->pAdr->Camera.pTargetCameraNow = 0;
	}
}
// perform EnvCondition (ENV_) 
bool TestEnvCondition(int ItemIndex, int EnvCondition, int EnvPosFlags, int DistanceEnv, int Extra)
{
	bool TestLara;
	StrItemTr4 *pItem;
	StrEnvForEnemy *pEnemy;
	DWORD FirstAnim;
	StrBoxCollisione *pBox;

	TestLara=false;
	if (ItemIndex == -1) {
		TestLara=true;
	}else {
		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];
		if (pItem->SlotID == 0) {
			TestLara=true;
		}
	}

	pEnemy= &Trng.pGlobTomb4->BaseEnvEnemy;

	pEnemy->TestLara= TestLara;
	if (TestLara == false) {
		pEnemy->IndiceOggetto = ItemIndex;
		pEnemy->pOggetto = pItem;
		FirstAnim = Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID].IndexFirstAnim;

		pEnemy->FirstAnim = FirstAnim;
		pBox=GetBestFrame(pItem);
		pEnemy->EnemyBox = *pBox;
	}

	if (Service(SRV_F_TestEnvCondition, EnvCondition, EnvPosFlags, DistanceEnv, Extra) ==0) return false;

	return true;

}

bool IsGraySector(void *pFloor)
{
	if (Service(SRV_F_IsBoxSettore, pFloor) == 0) return false;
	return true;


}
// return the status word of floor about climb features
// it returns 0 if there is no climb
// input: pFloor got from GetFloor() function
WORD FindClimbStatus(WORD *pFloor)
{
	int Index;
	WORD **ptr2_FloorData = (WORD **) 0x533948;
	WORD *ptr_FloorData;
	WORD Status;

	// indice data floor
	Index = pFloor[0];
	if (Index == 0) return 0;

	ptr_FloorData = *ptr2_FloorData;
	Status = ptr_FloorData[Index];

	if ((Status & 0x1f) == 6) {
		// valore climb)
		return Status;
	}
	if (Status & 0x8000) return 0;
	Index++;
	// provare il successivo
	Status = ptr_FloorData[Index];
	if ((Status & 0x1f) == 6) return Status;

	return 0;

}
// check if exist floor type on current floor
bool FindFloorType(WORD *pFloor, WORD Type)
{
	WORD **ptr2_FloorData = (WORD **) 0x533948;
	WORD *ptr_FloorData;
	int Index;
	WORD Status;

	Index=pFloor[0];

	if (Index ==0) return false;

	ptr_FloorData = *ptr2_FloorData;

	do {
		Status = ptr_FloorData[Index];
		if ((Status & 0x1f) == Type) return true;
		Index++;
	}while ((Status & 0x8000)==0);

	return false;

}

// format text with paraemters "%d"  "%s" ect.
char *FormatText(char *szFormat, ...)
{
	static char InternalBuffer[512];

    va_list pArgs;
    va_start(pArgs, szFormat);
    vsprintf(InternalBuffer, szFormat, pArgs);
    va_end(pArgs);

	return InternalBuffer;
}

void MyMessageBox(char *pMessaggio, char *pTitolo)
{
	static HWND* pTombWind4 = (HWND*) 0x75385C;  //  ;HandleWindowMain
					
	MessageBox(*pTombWind4,pMessaggio,pTitolo,MB_APPLMODAL);



}
// FOR_YOU:
// Try to show a message box with the wished text (pMessage)
// if it's not possible, because the game is in full screen (exclusive) mode
// omit the message box but it (always) will write the message in the tomb4 log
// You should use this function only for debugging or to signal a severe error
bool TryMessageBox(char *pMessage)
{
	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMai



	SendToLog(pMessage);
	if (*pTombWind4 == 0 ) {
		MyMessageBox(pMessage, TexMyPluginName);
		return true;
	}
	return false;
}
// FOR_YOU:
// detect if the game is in exclusive (full) screen mode.
// when there is the exclusive mode, you cann't show windows, but the direct function are faster and the 
// program can have higher ambitions about number of particles and other skills.
bool IsFullScreenMode(void)
{
	BYTE **p2_BaseGlobale = (BYTE **) 0x754468;
	BYTE *pBaseGlobale;

	pBaseGlobale = *p2_BaseGlobale;

	if (pBaseGlobale==NULL) return false;

	if (pBaseGlobale[0x4c] & 0x02)  return false;
	return true;

}

// write in tomb4 a new patch and perform all checks about further conflicts
// return 
// an APPC_ value (APPC_OK  all's ok, or an APPC_ warning or error)
// note: se returned value is less (<) than APPC_OK it means an error
//       while if error code is greater than (>) APPC_OK it means a warning
int ApplyCodePatch(DWORD Offset, BYTE *pVetBytes, int TotBytes) 
{
	bool TestWarnings;
	StrPatchInfo DataPatch;

	DataPatch.pVetItems = pVetBytes;
	DataPatch.ErrorCode=0;
	DataPatch.NewValue=0;
	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES;
	DataPatch.PluginId = Trng.IdMyPlugin;
	DataPatch.StartOffset = Offset;
	DataPatch.TotItems = TotBytes;

#ifdef DEBUG_ON
	TestWarnings=true;
#else
	TestWarnings=false;
#endif

	return Trng.SetNewPatch(&DataPatch, TestWarnings);

}
// write in tomb4 a new patch and perform all checks about further conflicts
// return an APPC_ value (APPC_OK  all's ok, or an APPC_ warning or error)
// note: this function is almost the same of ApplyCodePatch() function but in this case
// you add the infos about a zone of code (whole procedure) that will be relocated and never used in tomb4
// you have to type start and final offset of code no more reachable in tomb4. 

int ApplyRelocatorPatch(DWORD Offset, BYTE *pVetBytes, int TotBytes, DWORD ProcStart, DWORD ProcEnd)
{
	bool TestWarnings;
	StrPatchInfo DataPatch;

	DataPatch.ErrorCode=0;
	DataPatch.NewValue=0;
	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES | TYPP_RILOCATOR;
	DataPatch.PluginId = Trng.IdMyPlugin;
	DataPatch.StartOffset = Offset;
	DataPatch.TotItems = TotBytes;
	DataPatch.pVetItems = pVetBytes;
	DataPatch.ProcStart = ProcStart;
	DataPatch.ProcEnd = ProcEnd;

#ifdef DEBUG_ON
	TestWarnings=true;
#else
	TestWarnings=false;
#endif

	return Trng.SetNewPatch(&DataPatch, TestWarnings);
}
// apply a patch on different, non contiguous zones, where there are code like:   
// call OldAddress
// and replace OldAddress with supplied NewDestAddress value
// In pVetOffset there will be an array of tomb4 offset where perform the changes
// TotOffset is the amount of valid offset pointed by pVetOffset
// Note: The offsets in pVetOffset should be not the address you see disassembly but that value +1
// because it has to point to relative dword value to computer jump address.
// example:
// if the disassembly is:  
// 401021: 		call OldAddress
// you have to type in pVetOffset the offset 0x401022 (i.e. 0x401021+1)
// return an APPC_ value (APPC_OK  all's ok, or an APPC_ warning or error)
int ApplyCallPatch(DWORD *pVetOffsets, int TotOffsets, DWORD NewDestAddress)
{

	bool TestWarnings;
	StrPatchInfo DataPatch;

	DataPatch.ErrorCode=0;
	DataPatch.NewValue = NewDestAddress;
	DataPatch.PatchType = TYPP_PARAMETRIC | TYPP_PARAMETRIC_CALL;
	DataPatch.pVetItems = pVetOffsets;
	DataPatch.TotItems = TotOffsets;
	DataPatch.PluginId = Trng.IdMyPlugin;


#ifdef DEBUG_ON
	TestWarnings=true;
#else
	TestWarnings=false;
#endif

	return Trng.SetNewPatch(&DataPatch, TestWarnings);
}
// This function apply a patch, in tomb4 code, changing some single costant in non-contiguos way, 
// setting all those oldvalues, with same NewValue supplied as input
// return an APPC_ value (APPC_OK  all's ok, or an APPC_ warning or error)
int ApplyParametricPatch(StrParamPatch *pVetParamList, int TotParamList, int NewValue)
{
	bool TestWarnings;
	StrPatchInfo DataPatch;

	DataPatch.ErrorCode =0;
	DataPatch.NewValue = NewValue;
	DataPatch.PatchType = TYPP_PARAMETRIC | TYPP_PARAMETRIC_CONST;
	DataPatch.PluginId =  Trng.IdMyPlugin;
	DataPatch.pVetItems = pVetParamList;
	DataPatch.TotItems = TotParamList;

#ifdef DEBUG_ON
	TestWarnings=true;
#else
	TestWarnings=false;
#endif
	return Trng.SetNewPatch(&DataPatch, TestWarnings);
}
// this function will apply a patch to given tomb4 code range, to restore original tomb4 code, removing any
// kind of previous patch in that range
// return an APPC_ value (APPC_OK  all's ok, or an APPC_ warning or error)
int ApplyRestoreCodePatch(DWORD StartOffset, DWORD EndOffset)
{
	bool TestWarnings;
	StrPatchInfo DataPatch;
	
	DataPatch.ErrorCode=0;
	DataPatch.StartOffset = StartOffset;
	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES | TYPP_RESTORE;
	DataPatch.TotItems = EndOffset - StartOffset +1;
	DataPatch.PluginId = Trng.IdMyPlugin;
	DataPatch.pVetItems=NULL;
#ifdef DEBUG_ON
	TestWarnings=true;
#else
	TestWarnings=false;
#endif
	return Trng.SetNewPatch(&DataPatch, TestWarnings);
}

// Used to reserve a little zone of (previously) free data memory located in tomb4 executable
bool SetReservedDataZone(DWORD StartOffset, DWORD NBytes)
{
	int Result;


	Result = Service( SRV_SetReservedDataZone, StartOffset, NBytes);
	if (Result == 1) return true;
	return false;


}
// FOR_YOU: function to compare the current version number of tomb_nextgeneration.dll
// with the version number supplied in input.
// you can use this function to verify that the dll version is in the range you wish for your plugin.
// result:  +1 = trngVersion > than Input
// result:  =0 = trngversion is the same than input
// result:  -1 = trngVersion < than Input
int CompareTrngVersion(WORD VetVersion[])
{
	int i;
	WORD *pTrngVer;
	int n;

	pTrngVer = Trng.pGlobTomb4->BaseVersione.VetVersione;

	n=0;
	
	for (i=0;i<4;i++) {
		if (pTrngVer[i] > VetVersion[i]) {
			n = 1;
			break;
		}
		if (pTrngVer[i] < VetVersion[i]) {
			n = -1;
			break;
		}
	}

	return n;

}
// return an SKIP_ value to test with & operator about special moments of the game.
// I called it "skip" because many features should be disabled when there is one of these special phases

DWORD FindSkipPhase(void)
{
	DWORD FlagsSkip;


	FlagsSkip= SKIP_NONE;

	if (*Trng.pGlobTomb4->pAdr->pFadeScreen) FlagsSkip |= SKIP_FADE;

	if (*Trng.pGlobTomb4->pAdr->pTestLoading) FlagsSkip |= SKIP_LOADING_LEVEL;
  
	if (*Trng.pGlobTomb4->pAdr->Camera.pModeCameraNow  == 1) FlagsSkip |= SKIP_FIXED_CAMERA;	

	if (*Trng.pGlobTomb4->pAdr->pTestFlybyInProgress) FlagsSkip |= SKIP_FLY_CAMERA;

	if (*Trng.pGlobTomb4->pAdr->pLevelNow == 0 &&
		(*Trng.pGlobTomb4->pAdr->pScriptMainFlags & 0x04)) FlagsSkip |= SKIP_TITLE_LEVEL;

	if (*Trng.pGlobTomb4->pAdr->pTestGrayScreen) FlagsSkip |= SKIP_GRAY_SCREEN;

	if (Trng.pGlobTomb4->TestSuspendObjectShowing == true) FlagsSkip |= SKIP_NO_VIEW_OGGETTI;

	if (*Trng.pGlobTomb4->pAdr->pZoomFactor != 0 && *Trng.pGlobTomb4->pAdr->pTestLaserSight ==0) FlagsSkip |= SKIP_BINOCULARS;

	if (*Trng.pGlobTomb4->pAdr->pTestLaserSight && (*Trng.pGlobTomb4->pAdr->pInputExtGameCommands & 0x200) != 0) FlagsSkip |= SKIP_LASER_SIGHT;

	if (Trng.pGlobTomb4->TestOverlapImage==true) FlagsSkip |= SKIP_FULL_IMAGE;

	return FlagsSkip;

}

// FOR_YOU:
// find the ID of loaded plugin giving the name "plugin_name.dll"
// NOTE: you can use this procedure only AFTER that the CB_INIT_PROGRAM callback code has been performed.
// returns the ID of plugin, or -1 if there is no loaded plugin with the supplied name
int FindPluginID(char PluginName[])
{
	int i;

	for (i=0;i<Trng.TotPlugins;i++) {
		if (strcmpi(PluginName, Trng.pVetPluginNames[i])==0) {
			return i;
		}
	}

	SendToLog("ERROR: cann't locate plugin: \"%s\"", PluginName);


	return -1;

	
}
// FOR_YOU:
// perform a trigger using format for exported trigger for script (three number got from "Set Trigger Type" window of NGLE)
bool PerformExportedTrigger(char *pPluginName, int Arg1, int Arg2, int Arg3)
{
	int PluginId;

	if (pPluginName==NULL) {
		PluginId=0;
	}else {
		// ora dovrei usarre id di script		
		PluginId=FindPluginID(pPluginName);
	}
	if (PluginId == -1) return false;

	Arg1 &= 0xFFFF;

	if (Service(SRV_PERFORM_EXPORTED_TRIGGER, PluginId, Arg1, Arg2, Arg3)>0) return true;
	return false;


}


// FOR_YOU:
// perform an (existing) flipeffect trigger with the given data
bool PerformFlipeffect(char *pPluginName, int FlipNumber, int Arg1, int Arg2)
{
	int TimerField;
	int PluginId;

	if (Arg2==0) {
		TimerField=Arg1;
	}else {
		TimerField = Arg1 | (Arg2 << 8);
	}
	if (pPluginName==NULL) {
		PluginId=0;
	}else {
		PluginId=FindPluginID(pPluginName);
	}
	if (PluginId == -1) return false;
	
	Service(SRV_PERFORM_FLIPEFFECT, PluginId, FlipNumber, TimerField);
	return true;

}


// FOR_YOU:
// perform an (existing) action trigger with the given data
void PerformActionTrigger(char *pPluginName, int ActionNumber, int ObjectIndex, int ExtraTimer)
{
	int PluginId;
	int Index;

	if (pPluginName==NULL) {
		PluginId=0;
	}else {
		PluginId=FindPluginID(pPluginName);
		if (PluginId==-1) return;
	}

	if (ObjectIndex & NGLE_INDEX) {
		Index = ObjectIndex & MASK_NGLE_INDEX;
		ObjectIndex = FromNgleIndexToTomb4Index(Index);
	}
	
	Service(SRV_PERFORM_ACTION, PluginId, ActionNumber, ObjectIndex, ExtraTimer);

}

// FOR_YOU:
// perform an (existing) condition trigger with given data and returns the
// result of the condition :
// true (eax = 1) when the condition is true
// false: (eax = 0) when the condition is false
bool PerformConditionTrigger(char *pPluginName, int ConditionNumber, int ObjectField, int Extra)
{

	int PluginId;
	int Index;

	if (pPluginName==NULL) {
		PluginId=0;
	}else {
		PluginId=FindPluginID(pPluginName);
		if (PluginId==-1) return false;
	}
	if (ObjectField & NGLE_INDEX) {
		Index = ObjectField & MASK_NGLE_INDEX;
		ObjectField = FromNgleIndexToTomb4Index(Index);
	}

	if (Service(SRV_PERFORM_CONDITION, PluginId, ConditionNumber, ObjectField, Extra)!=0) return true;

	return false;

}
// standalone function to read direct input.
// Returns enumCMD commands and updates Trng.pGlobTomb4->pAdr->pVetInputKeyboard  array and other pInput.. variables
// note: it should be used only in closed loops, where standard direct input reading (of tomb4) has been skipped.
DWORD ReadDxInput(void)
{
	
	return Service(SRV_F_ReadDxInput);
}
// read keyboard and show correspeonding typed text in hDC device context in zone of pRect
// arguments:
// hDC : handle of device context where printing the text
// Buffer[] : character buffer where store typed text
// MaxChars : max number of character that user can type
// RIB_Flags : flags enumRIB_ to set preferences for input box
// SfxSound: number of sound effect to play for each key hit (if enabled in RIB_Flags)
// returned values:
//		0 = go on, waiting input
//      1 = completed with ENTER 
//     -1 = completed with ESCAPE
// note: Before calling this function you should have alrady set font and colors in hDC
//       and update direct input (when it's necessary) calling ReadDxInput() function
//       You should also intialise the buffer to "" (Buffer[0]=0), outside and before of waiting input loop
int ReadInputBox(HDC hDC, RECT *pRect, char Buffer[], DWORD MaxChars, WORD RIB_Flags, int SfxSound)
{
	return Service(SRV_F_ReadInputBox, hDC, pRect, Buffer, MaxChars, RIB_Flags, SfxSound);
}

// suspend (stop but saves its cd number) current level audio track. Then you'll be able to resume it 
// using a call to ResumeAudioTrack
// arguments:
// NewAudioTrack : optional new audio track to play or -1 if you want silence
// TestLoop: in the case you gave a valid NewAudioTrack you can set with TestLoop if the new track will
//           played in looped mode or only once.
// note: This function should be used when you start some control panel that quit (temporarily the common game) 
//       to supply new sound for new environment and then restore, at coming back in game, the old audio
//       track using coupled function ResumeAudioTrack()

void SuspendAudioTrack(int NewAudioTrack, bool TestLoop)
{

	Service(SRV_F_SuspendAudioTrack, NewAudioTrack,TestLoop);

}

// to call only after a previous call to SuspendAudioTrack() function.
// this function restore previous audio track suspended by SuspendAudioTrack
// no argument required
void ResumeAudioTrack(void)
{
	Service(SRV_F_ResumeAudioTrack);	
}

// create a WindowsFont (to select in hDC) using data in pFont to set its features
// arguments:
// pFont: pointer to StrWindowsFont structure with settings about wished font
// TestNoResize:  if == true, you want that the given size (in pFont data) will be preserved in spite
//               to give off about other settings of pFont
// return the handle of created font. Note: same handle will be saved also in pFont->hFont field
HFONT CreateWindowsFont(StrWindowsFont *pFont, bool TestNoResize)
{
	return (HFONT) Service(SRV_F_CreateWindowsFont, pFont, TestNoResize);
}

// free (delete) windows font and, before deleting it, remove it for Device Context where it had been selected
// you should use this function only after CreateWindowsFont() function and then having selected 
// that font in some device context
void FreeWindowsFont(StrWindowsFont *pFont)
{
	Service(SRV_F_FreeWindowsFont, pFont);
}
// code called in raw mode from trng to pass over checks about different processe rights
// in eax there is the  direct call required (NGDC_..)
// in other registrers the further parameters
// output in eax
// note: reserved for future usages
BEGIN_ASM_PROC(CallFromTrng)
	xor eax, eax
	retn
END_ASM_PROC


// This is called at start to get the address of global trng data
// The address of global trng structure will be in wrote 
// in "Trng.pGlobTomb4" variable
// This function gets also the own plugin ID required for all services 
// and callbacks
// The plugin Id will be stored in: Trng.IdMyPlugin
void GetTrngInfo(void)
{

	StrTrngInfos *pSrcInfo = (StrTrngInfos *) 0x4A6E70;

	Trng = *pSrcInfo;
	// the plugin returns the setting about the address of MainPatcher function:
	pSrcInfo->pAdrDllPatcher = &MainPatcher;
	// and the address in tomb4 code where this address will be saved: 
	pSrcInfo->AdrTomb4Patcher = MyTomb4PatcherAddress; 
	// and the address for directcall from trng to plugin code
	pSrcInfo->pDirectCallBack = &CallFromTrng;

	// copy current plugin name
	strcpy(TexMyPluginName, pSrcInfo->pMyPluginName);
	
	// initialise auto-enumerator for some mnemonic constants
	InitialiseEnums();

	// and the current version (debug or release)
#ifdef DEBUG_ON
	pSrcInfo->TestDebugMode = 1;
#else
	pSrcInfo->TestDebugMode = 0;
#endif
}
// FOR_YOU:
// this is an easy function to get dynamic memory for your targets
// In spite it's more easy and comfortable to use static memory
// assigned with a simple row like this:
// BYTE MyZoneMem[30000];
// in some cirucstance you could don't know in advance the size of memory you
// need. In this situation you can get the wished size of memory
// using this GetMemory() function
// note: if there is an error it returns NULL (eax=0)
// at end you should free the memory calling the FreeMem() function
// passing to it, like argument, the address you received from GetMemory() 
void *GetMemory(DWORD SizeOfMemory)
{
	void *pMem;

	pMem = malloc(SizeOfMemory);
	
#ifdef DEBUG_ON
	if (pMem == NULL) {
		SendToLog("ERROR: failed the attempt to get dynamic free memory of %d bytes",SizeOfMemory);
		
	}
#endif
return pMem;

}


// FOR YOU:
// resize (usually get it wider) a memory zone previously allocated with GetMemory() function
void *ResizeMemory(void * pOldMemory, DWORD NewSize)
{
	if (pOldMemory==NULL) {
		return GetMemory(NewSize);
	}

	return realloc(pOldMemory, NewSize);


}
// procedure to store ng token following syntax rule of all ng headers
// this procedure used to store your data in savegame. see cbSaveGame callback

// NGTag = kind of ng token. NGTAG_... constant
// TotItem = number of items if we are saving a vector, while when it's not a vectore
//		 in this argument you type NO_ARRAY
// SizeSingleItem = Size of single record for vector, or the total size of structure to save
// pData   =  points to begin address of vector or structure to save
// pVetExtra  = pointer to memory pointer zone where it will be saved the data. this function will allocate it and resize it when it's necessary
//			you'll have to free pVetExtra when you do not use it.
// pNWords = pointer for number of words stored in pVetExtra
    
void AddNGToken(WORD NGTag, DWORD TotItem, 
				   DWORD SizeSingleItem, void *pData,
				   WORD **p2VetExtra, int *pNWords)
{
	WORD TotRecord;
	DWORD TotBytes;
	DWORD NumeroWords;
	DWORD SizeMem;
	WORD *pVetExtra;
	int IndiceWords;

	pVetExtra = *p2VetExtra;


	IndiceWords  = *pNWords;
	
	SizeMem = IndiceWords * 2 + 100;

	if (TotItem == NO_ARRAY) {
		TotRecord=1;
		TotBytes = SizeSingleItem;
		
		NumeroWords = 2 + (TotBytes/2);

		if (TotBytes & 1) {
			// skip message if bytes amout is onlt = 1
			if (TotBytes > 1) {
				SendToLog("WARNING: in AddNGToken(): Size of structure for Tag=0x%X is not even (%d). It has been added one extra byte.",
					NGTag, TotBytes);
			}
			// increase by 1 number of words to host the extra byte
			NumeroWords++;
	
		}
		if (NumeroWords > 0x7fff) {
			// ci vorranno due words quindi aumentare di 1 le words
			NumeroWords++;
		}

		SizeMem += NumeroWords * 2;
		if (IndiceWords) {
			pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);
		}else {
			// e' azzerato, allocare adesso
			pVetExtra = (WORD *) GetMemory(SizeMem);
		}

		if (NumeroWords > 0x7fff) {
			// e' una dword
			pVetExtra[IndiceWords++] = (WORD) ((NumeroWords >> 16) | 0x8000);
			pVetExtra[IndiceWords++] = (WORD) (NumeroWords & 0xffff);

		}else {
			pVetExtra[IndiceWords++] = (WORD) NumeroWords;
		}	

		pVetExtra[IndiceWords++] = NGTag;

		memcpy(&pVetExtra[IndiceWords], pData, TotBytes);

		IndiceWords += (TotBytes / 2);

		if (TotBytes & 0x001) IndiceWords++;


	}else {

		TotRecord = (WORD) TotItem;
		TotBytes = SizeSingleItem * TotRecord;

		if (TotBytes & 1) TotBytes++;

		NumeroWords = 3 + (TotBytes /2);

		if (NumeroWords > 0x7fff) {
			NumeroWords++;
		}

		SizeMem += NumeroWords * 2;

		if (IndiceWords) {
			pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);
		}else {
			// e' azzerato, allocare adesso
			pVetExtra = (WORD *) GetMemory(SizeMem);
		}
		if (NumeroWords > 0x7fff) {
			pVetExtra[IndiceWords++] = (WORD) ((NumeroWords >> 16) | 0x8000);
			pVetExtra[IndiceWords++] = (WORD) (NumeroWords & 0xffff);
		}else {
			pVetExtra[IndiceWords++] = (WORD) NumeroWords;
		}

		pVetExtra[IndiceWords++] = NGTag;
		pVetExtra[IndiceWords++] = TotRecord;

		memcpy(&pVetExtra[IndiceWords], pData, TotBytes);

		IndiceWords += (TotBytes / 2);
	}



	*pNWords = IndiceWords;
	*p2VetExtra = pVetExtra;
}

void AddTokenFinalSequence(WORD **p2VetExtra, int *pNWords)
{

	DWORD SizeMem;
	WORD *pVetExtra;
	int IndiceWords;

	pVetExtra = *p2VetExtra;
	IndiceWords  = *pNWords;

	SizeMem = (IndiceWords+2) * 2;

	if (IndiceWords) {
		pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);
	}else {
		// e' azzerato, allocare adesso
		pVetExtra = (WORD *) GetMemory(SizeMem);
	}	

	pVetExtra[IndiceWords++]= NGTAG_END_SEQUENCE;
	pVetExtra[IndiceWords++]= NGTAG_END_SEQUENCE;
	
	*p2VetExtra= pVetExtra;
	*pNWords= IndiceWords;
	
}

// parse header ng word array
// input:
//      pNGArray = word array of whole ng header
//		CurrentIndex = first index from whom begin current parsing
//      pParseNGField = pointer to StrParseNGField structure that will host results of current parsing
// output:
//		values written in pParseNGField:
//		DWORD NextIndex;  // Index where will start next chunk
//		word *pData;      // pointer to data memory for currentIndex field
//		DWORD StartDataIndex // index of first word for currentindex field with effective data
//		DWORD SizeData;   // size of data (in bytes) pointed by pData
//		WORD  Type;       // Type of CurrentIndex chunk (NGTAG_ value usually)
//		
// returned (bool): 
//		false = no more data in ng header (the values in pParseNGField are not meaninguf)
//		true = read data and stored results in pParseNGField structure

bool ParseNgField(WORD *pNgArray, DWORD CurrentIndex, 
										StrParseNGField* pParseNGField)
{
	DWORD Word1, NumberOfWords;
	int i;
	DWORD ExtraWords;


	i = CurrentIndex;


	if (pNgArray[i] & 0x8000) {
		// size e' DWORD
		Word1 = pNgArray[i++] & 0x7fff;
		NumberOfWords = Word1 * 65536 + pNgArray[i++];
		ExtraWords = 3;
	}else {
		// size e' WORD
		NumberOfWords = pNgArray[i++];
		ExtraWords = 2;
	}
	
	if (NumberOfWords == NGTAG_END_SEQUENCE) return false;

	pParseNGField->NextIndex = CurrentIndex + NumberOfWords;
	pParseNGField->Type = pNgArray[i++];
	pParseNGField->pData = &pNgArray[i];
	pParseNGField->StartDataIndex = i;
	pParseNGField->SizeData = (NumberOfWords-ExtraWords) * 2;
	
	return true;
}

// FOR_YOU:
// Get the text of the string with StringIndex index reading 
// it from the script.dat
// Return the text of the script.dat string with index = StringIndex
// if you wish get an ExtraNG string, you have to add to the index 
// the value STRING_NG
char * GetString(int StringIndex)
{
	char *pChar;
	int i;
	WORD Indice;
	static WORD ** p2IndiciStringheDat = (WORD **) 0x7FD154;
	WORD *pIndiceStringheDat;
	static char **p2StringheScriptDat = (char**) 0x7FD198;
	char *pStringheScriptDat;
	static char MexNotFound[]= "STRING NOT FOUND";

	pIndiceStringheDat = *p2IndiciStringheDat;
	pStringheScriptDat = *p2StringheScriptDat;

	if (StringIndex & STRING_NG) {
		// extra NG string
		Indice= StringIndex & MASK_STRING_INDEX;

		for (i=0;i<Trng.pGlobTomb4->TotExtraStrings;i++) {
			if (Trng.pGlobTomb4->VetExtraStrings[i].Indice == Indice) {
				pChar = Trng.pGlobTomb4->VetExtraStrings[i].pTesto;

				return pChar;
			}
		}
		// not found. if we are in debug version lets a mexage in tomb4_log
#ifdef DEBUG_ON
		SendToLog("ERROR: cann't locate extra ng string with index = %d", StringIndex & MASK_STRING_INDEX);
#endif
		return MexNotFound;

	}
	// string is not of extra ng kind
	Indice = pIndiceStringheDat[StringIndex];
	pChar = &pStringheScriptDat[Indice];
	return pChar;

}





// FOR_YOU:
// used to discover to what ngle index corresponds the internal tomb4 index
// you found in game.
// Usually you'll use this function only for debugging
int FromTomb4IndexToNgleIndex(int TombIndex)
{
	int i;

	i=Trng.pGlobTomb4->VetRemapInverseObjects[TombIndex];

	if (i == -1) {

		// not found
		SendToLog("ERROR: the tomb4 index %d doesn't correspond to any ngle index", TombIndex);
	}
	return i;
}

// discover the lenght (size) of an alread opened file
long FileLenght(FILE *tempfile)
{
	long  tempdim;

	

	fseek(tempfile,0,SEEK_END);
	tempdim=ftell(tempfile);
	fseek(tempfile,0,SEEK_SET);



	return tempdim;
}

// FOR_YOU:
// this function verify if the file with pFileName path exists or less
// true (eax=1) it exists
// false (eax=0) it doesn't
// note: this function will be called automatically from LoadFile() function
bool IsThereFile(char *pFileName)
{
	struct stat stbuffer;


	if (pFileName[0] == 0) return false;

	if (stat(pFileName,&stbuffer) != 0) return false;
	return true;
}


// FOR_YOU:
// free the memory previously allocated by GetMemory() or LoadFile() functions
void FreeMemory(void *pMem)
{


	free(pMem);

}


// FOR_YOU: function used to require a callback
bool GetCallBack(int CallBackCB, int CBT_Flags, WORD Index, void *pProc) 
{

	return Trng.RequireCallBack(Trng.IdMyPlugin, CallBackCB, CBT_Flags, Index, pProc);
}

// FOR_YOU:
// this function load in memory a disk file and return the memory address
// where the file has been loaded
// it writes also in pSize the size of the file
// note: when you completed your operations on this file you should 
// call FreeMemory() passing to it the address you got from LoadFile()
// to free the allocated memory.
// if the function fails it returns NULL (eax=0)
// note: if you are not interested about the size of the file you
// can use NULL (0) like pSize
BYTE *LoadFile(char *pFileName, DWORD *pSize)
{
	DWORD SizeFile;
	FILE *pFile;
	BYTE *pMem;

	if (IsThereFile(pFileName) == false) {
#ifdef DEBUG_ON
		SendToLog("ERROR in LoadFile(): missing file \"%s\"",pFileName);
		
#endif
		return NULL;
	}
	pFile = fopen(pFileName,"rb");
	if (pFile == NULL) {
#ifdef DEBUG_ON
		SendToLog("ERROR trying to open file: %s", pFileName);

#endif
		return NULL;
	}
	SizeFile=FileLenght(pFile);
	pMem = (BYTE *) GetMemory(SizeFile);
	if (pMem==NULL) {
		fclose(pFile);
		return NULL;
	}
	fread(pMem, SizeFile,1, pFile);
	fclose(pFile);
	if (pSize != NULL) *pSize = SizeFile;

	return pMem;
}

// used by the GET_ROOM_OFFSET() macro
void * GetRoomOff(int RoomIndex, DWORD RoomField)
{

	StrRoomTr4 *pRoomNow;

	pRoomNow= &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex];

	BEGIN_ASM
		mov ecx, RoomField
		add dword ptr [pRoomNow], ecx
	END_ASM


	return pRoomNow;


}
// used by the GET_ITEM_OFFSET() macro
void * GetItemOff(int ItemIndex, DWORD ItemFields) 
{
	StrItemTr4 *pItem;

	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

	BEGIN_ASM
		mov ecx, dword ptr [ItemFields]
		add dword ptr [pItem], ecx
	END_ASM

	return pItem;

}

// used by the GET_STATIC_OFFSET() macro
void * GetStaticOff(int StaticIndex, int RoomIndex, DWORD StaticField)
{
	StrMeshInfo *pStatic;

	pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];


	BEGIN_ASM
		mov ecx, dword ptr [StaticField]
		add dword ptr [pStatic], ecx
	END_ASM

	return pStatic;
}



// used by CONVERT_STATIC_INDEX() macro (for asm code)
// return   in low word of eax the StaticIndex
//  and     in high word of eax the RoomIndex

DWORD ConvNgleStaticIndex(WORD NgleStaticIndex) 
{

	DWORD StaticIndex;
	DWORD RoomIndex;
	DWORD Result;

	StaticIndex = (DWORD) Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceStatic;
	RoomIndex = (DWORD) Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceRoom;

#ifdef DEBUG_ON
	if (Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceStatic == -1) {
		SendToLog("ERROR: the NGLE static index to convert (%d) is wrong. No static item coincides with it", 
								NgleStaticIndex);

	}
#endif
	Result = StaticIndex;
	Result |= (RoomIndex << 16);

	return Result;
	
}

void SendErrorToDiskLog(char *pMessage, DWORD PluginID, bool TestMsgBox)
{

	Service(SRV_F_InviaErroreLog, pMessage, PluginID, TestMsgBox);

}

// convert coordinate (or size, width, height) values stored in pRect, from microunits to real screen coordinates
// in according with current tomb raider resolution
// you'll use this function to keep your image, sprite, mesh, in same relative position on the screen
// in spite tomb resolution could be different from that you used in the project phase
// note: 500 mu, becomes always the middle pixel. For instance if current resolution is 800x600
// 500 will become 400 on x axis, and 300 on y axis
void ConvertMicroUnits(RECT *pRect)
{
	Service(SRV_F_ConvertMicroUnits, pRect);
}
// Allocate image with number NImage, copying its data in pRecord structure
// if NImage is -1, it will allocate a memory Device Context and an (empty) compatible bitmap with 
// size given by ForceSizeX, ForceSizeY
// if ForceSizeX, ForceSizeY are -1, then it will be used current tomb raider screen size
// when NImage is a positive number, it will be loaded the image stored in subfolder "pix" with name
// Image<NImage>.bmp
// for instance if NImage = 14, it will be loaded "trle\pix\image14.bmp"
// this function can allocate crypted images (with "@" prefix) or preloaded images (stored in script.dat file.
// note: you cann't use the number 999, because it reserved for temnporary screenshot images
bool AllocateImage(int NImage, StrRecordImage *pRecord, int ForceSizeX, int ForceSizeY)
{
	if (Service(SRV_F_AllocateImage, NImage, pRecord, ForceSizeX, ForceSizeY)) return true;
	return false;
}

// free an image previously allocated usign AllocateImage() function.
void FreeImage(StrRecordImage *pRecord)
{
	Service(SRV_F_FreeImage, pRecord);
}
// Allocate handle of tomb raider device context (HDC), allocating furtherly an image with current 
// tomb raider screen or an empyt memory device context with its bitmap
// if TestHdcTemp == true, then it will be created a memory device context with same size of tomb raider screen
// if TestWriteHdc == true, we mean perform a writing operation in tomb hdc, while when TestWriteHdc==false 
// we want only read curent tomb raider screen
// the structure pointer by pBase will be initialised from this function
// warning: you cann't keep a write tomb hdc for many time. You should catching it, only a moment first
// to write on screen, and then immediately freeing it.

bool AllocateTombHdc(StrShowImage *pBase, bool TestHdcTemp, bool TestWriteHdc)
{
	if (Service(SRV_F_AllocateTombHdc, pBase, TestHdcTemp, TestWriteHdc)) return true;
	return false;
}

// draw sprite with index SpriteIndex stored in Slot.
// Opacity permits to set transparency factor: 255 (0xff) max opacity, 0 fully transparent
// you can add a color gradient to sprite with Color argument. This color will be more visible if
// you set some transparence for sprite.
// if you don't wont adding any color gradient, set color to black, 0
// note: this function will work only if you execute it when the drawing operations are currently opened.
// note: The values typed in RECT structure are:
//       Left = X Origin Coordinate
//       Top  = Y Origin Coordinate
//       Right = Width (X size)
//       Bottom = Height (Y Size)
void DrawSprite2D(RECT *pRect, WORD Slot, int SpriteIndex, BYTE Opacity, COLORREF Color)
{
	Service(SRV_F_DrawSprite2D, pRect, Slot, SpriteIndex, Opacity, Color);
}

// it draws the mesh with absolute index = MeshIndex in 3d position with given facing set in pPos structure
//  note: this function will work only if you execute it when the drawing operations are currently opened.
void DrawMesh3D(StrPos3d *pPos, int MeshIndex)
{
	Service(SRV_F_DrawMesh3D, pPos, MeshIndex);
}
// it draws object of given Slot, on the screen in (CordX, CordY) position with given facing on three axis
// Distance will reduce or magnify the size of the object
// note: really, the position in 2d coordinates (CordX, CordY) is not very precise, since the Distance and 
//      the pivot of the object (the point where it has his (x,y,z) origin) could change a bit the 
//      effective 2d position

void DrawObject2D(WORD Slot, int CordX, int CordY, WORD OrientX, WORD OrientY, WORD OrientZ, int Distance)
{
	Service(SRV_F_DrawObject2D, Slot, CordX, CordY, OrientX, OrientY, OrientZ, Distance);
}

// free the tomb raider hdc gotten with AllocateTombHdc() function.
// if you set TestKeepTempHdc==true, the temporary hdc (creatd with AllocateTombHdc() function) will be not
// released.
void FreeTombHdc(StrShowImage *pBase, bool TestKeepTempHdc)
{
	Service(SRV_F_FreeTombHdc, pBase, TestKeepTempHdc);
}

bool CheckControlGlobTomb4(void)
{

	if (Trng.pGlobTomb4->CheckValue1_3_0_0 != 0x01234567) {
		// globtomb4 changed 
		SendErrorToDiskLog("ERROR: failed check of alignment value of GlobTomb4 structure for 1.3.0.0 version", Trng.IdMyPlugin, false);
		return false;

	}

	return true;

}


// FOR_YOU:
// to get a new free record to store a progressive action

StrProgressiveAction * GetNewProgrAction(void)
{
	
	StrProgressiveAction *pAction;
	int i;

	pAction= &MyData.VetProgrActions[0];

	// look for first free record
	for (i=0;i<MyData.TotProgrActions;i++) {
		if (pAction->ActionType == AXN_FREE) {

			return pAction;
		}
		pAction++;
	}
	// no record free
	// increase number of allocated records
	if (MyData.TotProgrActions >= MAX_MYPROGR_ACTIONS) {
		// already reached max number of record (bad matter)
		// stole the record to older progressive action and send an error message if debug is on
		i= MyData.LastProgrActionIndex;

		pAction = &MyData.VetProgrActions[i];


		
#ifdef DEBUG_ON

		SendToLog("ERROR from GetNewProgrAction(): no more available StrProgressiveAction records. Cleared old ProgrAction with ActionType = %d and ItemIndex=%d",
			pAction->ActionType, pAction->ItemIndex);
	
	
#endif
		pAction->ActionType= AXN_FREE;
		// update next index to stole for older prograction
		i++;
		if (i >= MAX_MYPROGR_ACTIONS) {
			i = 0;
		}
		MyData.LastProgrActionIndex = i;

		return pAction;
	}
	// allocate new record
	i = MyData.TotProgrActions;
	pAction= &MyData.VetProgrActions[i];

	MyData.TotProgrActions++;
	return pAction;

}

// locate ColorRgb script command with IdColorRgb
// return the rgb color in COLORREF format
// input:  if TestInvert == true change sorting of Red Green Blue to have same format of Windows (suggested)
//         DefColor = color to return if the colorrgb has not been found (default color to use if error)
//         pMexCommand = text about what function called this function (for log)
COLORREF GetColorRgb(short IdColorRgb, COLORREF DefColor, bool TestInvert, char *pMexCommand)
{
	
	int Indice;
	COLORREF NewColor;
	StrSingleColors *pDest;
	StrColorRGB *pRgb;

	if (IdColorRgb < 0) {
		SendToLog("ERROR it has not been set the ID for ColorRbg in the script command %s", pMexCommand);
		return DefColor;
	}

	Indice = Trng.pGlobTomb4->BaseColoriRGB.VetID[IdColorRgb];
	
	if (Indice == -1) {
		SendToLog("INTERNAL ERROR: not found the ColorRgb command with id = %d (called from %s)", 
							IdColorRgb, pMexCommand);
		return DefColor;
	}
	pRgb = &Trng.pGlobTomb4->BaseColoriRGB.VetColori[Indice];

	if (TestInvert) {
		pDest = (StrSingleColors *) &NewColor;


		pDest->Blue = pRgb->Single.Red;
		pDest->Green = pRgb->Single.Green;
		pDest->Red = pRgb->Single.Blue;
		pDest->Unused = 0;
		return NewColor;
	}


	return pRgb->Colore;


}

int ConvertFromStrItemToItemIndex(StrItemTr4 * pItem)
{
	int BaseAdr;

	if (pItem==NULL) {
		SendToLog("ERROR: required conversion from StrItem to item index but the pointer for StrItem is NULL");
		return -1;
	}

	BaseAdr = (int) pItem;
	BaseAdr -= (int) Trng.pGlobTomb4->pAdr->pVetItems ;
	BaseAdr /= sizeof(StrItemTr4);

	return BaseAdr;
}

// read the value of Numeric (trng) variable corresponding to Code reference
// note: Code may be: the trigger value of "#VAR_NORMALS#", "#VAR_STORES#" (adding VAR_TYPE_STORE flag)
//       or #VAR_LONG_STORE# (adding VAR_TYPE_LONG_STORE) preset trigger list 
// note: If the code is from script (a variable placefodler code) you have to add the SCRIPT_CODE flag
// read Function Collection document for more infos about this function.
int ReadNumVariable(int Code)
{
	 
	return Service(SRV_F_ReadNumVariable, Code);
}

// Write Value in given numeric trng variable, corresponding to code parameter.
// note: Code may be: the trigger value of "#VAR_NORMALS#", "#VAR_STORES#" (adding VAR_TYPE_STORE flag)
//       or #VAR_LONG_STORE# (adding VAR_TYPE_LONG_STORE) preset trigger list 
// note: If the code is from script (a variable placefodler code) you have to add the SCRIPT_CODE flag
// read Function Collection document for more infos about this function.
void WriteNumVariable(int Code, int Value)
{
	Service(SRV_F_WriteNumVariable, Code, Value);

}

// read text trng variable whose code is stored in Code input parameter.
// the code can be a placefolder variable from ng_center's reference panel, and in this case
// you need to add with "|" operator the SCRIPT_CODE flag
// otherwise the code could be a value from the #VAR_TEXT#  parameter list of some trigger
char *ReadTextVariable(int Code)
{
	char *pChar;

	pChar = (char *) Service(SRV_F_ReadTextVariable, Code);

	return pChar;
}

// write the given string pointed by pText in some trng text variable refered by Code parameter
// the code can be a placefolder variable from ng_center's reference panel, and in this case
// you need to add with "|" operator the SCRIPT_CODE flag
// otherwise the code could be a value from the #VAR_TEXT#  parameter list of some trigger
void WriteTextVariable(int Code, char *pText)
{
	Service(SRV_F_WriteTextVariable, pText);
}

// read some memory variable. Many trigger support operations on some critical memory zones divided in
// different groups. The value you get from preset trigger lists. The preset lists are: 
// #MEMORY_INVENTORY# , #MEMORY_SAVE#, #MEMORY_CODE#, #MEMORY_ITEM#, #MEMORY_SLOT# and #MEMORY_ANIMATION#
// when you type the value of this paraemter trigger you have to add the corresponding enumMEMT. flag
// for that list
// Read "Function Collection" tutorial for more infos
int ReadMemVariable(int Code)
{
	return Service(SRV_F_ReadMemVariable, Code);
}

// write a value to some memory variable.
void WriteMemVariable(int Code, int Value)
{
	Service(SRV_F_WriteMemVariable, Code, Value);
}

// from absanim to relanim

int GetRelAnim(StrItemTr4 *pItem, int AnimIndex)
{
	StrSlot *pSlot;
	int FirstAnimation;
	int RelativeIndex;
	
	pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

	FirstAnimation = pSlot->IndexFirstAnim;

	RelativeIndex = AnimIndex - FirstAnimation;

	return RelativeIndex;
}

// from relanim to absanim
int GetAbsAnim(StrItemTr4 *pItem, int AnimIndex)
{
	StrSlot *pSlot;
	int FirstAnimation;
	
	pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

	FirstAnimation = pSlot->IndexFirstAnim;

	return AnimIndex + FirstAnimation;

}

int ConvertTombRoomIndex2NgleIndex(int RoomIndex)
{
	int i;

	for (i=0;i<MAX_ROOMS;i++) {
		if (Trng.pGlobTomb4->VetRemapRooms[i] == RoomIndex) return i;
	}

	return -1;

}
// Convert() function allows to conver many different kind of values.
// in first argument you type enumCONV.
// and then you'll see the list of possible conversions
// them, following parameters (Index, SecondarIndex ad pPointer) will have different usage 
// in accoding with chosen CONV type.
// About * pPointer it's a generic pointer, when a CONV function requires a value for pPointer
// youl type the variable, of right typed, as suggested by description for that CONV, using the "&" operator 
// for instance  "& StaticIndex" or "& MyRect" ect.
// See collection function tutoriali for more infos.
int Convert(int CONV_Type, int Index, int SecondaryIndex, void * pPointer)
{
	int RoomIndex;
	int StaticIndex;
	StrItemTr4 *pItem;
	StrAnimationTr4 *pAnim;

	switch (CONV_Type) {
	case CONV_FrameIndexFromAbsToRelative:
		pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[SecondaryIndex];
		if (Index < pAnim->FrameStart || Index > pAnim->FrameEnd) {
			return -1;
		}
		return Index - pAnim->FrameStart;
	case CONV_FrameIndexFromRelativeToAbs:

		pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[SecondaryIndex];
		return Index + pAnim->FrameStart;

	case CONV_ItemIndexFromNgleToTomb:
		return FromNgleIndexToTomb4Index(Index);

	case CONV_ItemIndexFromTombToNgle:
		return FromTomb4IndexToNgleIndex(Index);
	
	case CONV_StaticIndexFromNgleToTomb:
		if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==true) {
			* (int*) pPointer = StaticIndex;
			return RoomIndex;
		}

		return -1;

	case CONV_StaticIndexFromTombToNgle:
		return FromStaticIndicesToNgleIndex(Index, SecondaryIndex);

	case CONV_RectFromMicroUnitsToPixels:
		ConvertMicroUnits((RECT*) pPointer);
		return 1;

	case CONV_AnimIndexFromRelativeToAbs:
		pItem = (StrItemTr4 *) pPointer;
		return GetAbsAnim(pItem, Index);

	case CONV_AnimIndexFromAbsToRelative:
		pItem = (StrItemTr4 *) pPointer;
		return GetRelAnim( pItem, Index);

	case CONV_ItemFromStrItemTr4ToIndex:
		return ConvertFromStrItemToItemIndex((StrItemTr4 *) pPointer);

	case CONV_RoomIndexFromNgleToTomb:
		RoomIndex = Trng.pGlobTomb4->VetRemapRooms[Index];
		if (RoomIndex == -1) RoomIndex = Index;
		return RoomIndex;
	case CONV_RoomIndexFromTombToNgle:
		return ConvertTombRoomIndex2NgleIndex(Index);

	}

	SendToLog("WARNING: unknown CONV_ value (%d) for Convert() function", CONV_Type);
	return -1;			
}
// this is main locator of items.
// it return structure for moveables, static, rooms ect
// and data from script commands
// you can use the "enumGET...." values to see the list of GET_ constant you can use.
// returns "true' for success, and "false" for error (not found the item with that index)
bool Get(int GET_Type, int Index, int SecondaryIndex)
{

	int TombIndex;
	int RoomIndex;
	int StaticIndex;
	StrItemTr4 *pItem;
	StrMeshInfo *pStatic;
	StrGameInfo *pGame;
	bool TestConvert;
	StrLaraInfo *pInfo;
	StrItemTr4 *pLara;
	StrSlot *pSlot;
	WORD Flags;
	int z;
	int MeshIndex;
	WORD StateId;
	StrGenericCustomize *pCust;
	StrGenericParameters *pParam;
	WORD Slot;
	int i;
	StrMeshTr4 *pMeshRightHand;
	StrScriptSettings *pScript;
	static StrMemSelItems BsSelIndex;
	static StrFlipMap BsFlipMaps;


	switch (GET_Type) {
	case GET_FLIPMAPS:
		// fill BsFlipMaps structure with flipmap data
		BsFlipMaps.pVetButtonFlipMaps = Trng.pGlobTomb4->pAdr->Remap.pVetButtonFlipMaps;
		BsFlipMaps.pVetEnabledFlipMaps = Trng.pGlobTomb4->pAdr->Remap.pVetEnabledFlipMaps;
		BsFlipMaps.pVetFlipRooms = &Trng.pGlobTomb4->FlipMapRooms.VetRoomMain[0];
		BsFlipMaps.TotFlipRooms = Trng.pGlobTomb4->FlipMapRooms.TotFlipRooms;
		// link the pointer of BsFlipMaps to Get.pFlipMap field
		GET.pFlipMap = &BsFlipMaps;
		return true;
		
	case GET_VARIABLES:
		GET.Vars.pMemorySelected = &BsSelIndex;
		GET.Vars.pMemorySelected->pAnimationSelected = &Trng.pGlobTomb4->CurrentInventoryIndex;
		GET.Vars.pMemorySelected->pItemSelected = &Trng.pGlobTomb4->ItemIndexSelected;
		GET.Vars.pMemorySelected->pIventorySelected = &Trng.pGlobTomb4->CurrentInventoryIndex;
		GET.Vars.pMemorySelected->pSlotSelected = &Trng.pGlobTomb4->CurrentSlotIndex;
		GET.Vars.pTrngVars = Trng.pGlobTomb4->pBaseVariableTRNG;

		return true;

	case GET_INFO_ITEM:
		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			TombIndex=FromNgleIndexToTomb4Index(Index);
			if (TombIndex==-1) return false;
			Index= TombIndex;
		}
		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];
		GET.InfoItem.TestCreature=false;
		GET.InfoItem.TestEnabled =false;
		GET.InfoItem.TestSemiGod=false;
		GET.InfoItem.TestDoor=false;
		GET.InfoItem.TestOnlyExplode=false;


		// is it a creature?
		Slot=pItem->SlotID;
		pSlot=&Trng.pGlobTomb4->pAdr->pVetSlot[Slot];
		if (pSlot->Flags & enumFSLOT.AI_STANDARD) {
			GET.InfoItem.TestCreature =true;
			// is it enabled?
			if ((pItem->Objectbuttons & 0x8000)==0 && 
				(pItem->FlagsMain & 0x06) != 0x06) {
				GET.InfoItem.TestEnabled =true;
			}
			// is it semigod?
			if (pSlot->Vitality == (short) 0xC000) {
				GET.InfoItem.TestSemiGod=true;
			}
			// is it killable only with explosive ammo?
			if (pSlot->Flags & NEF_ONLY_EXPLODE) {
				GET.InfoItem.TestOnlyExplode=true;
			}

		}
		// is it a door?
		if ((Slot >= 122 && Slot <= 129) ||
			(Slot >= 322 && Slot <= 335)) {
			GET.InfoItem.TestDoor=true;
			// is it open or close?
			if (pItem->StateIdCurrent == 0) {
				GET.InfoItem.TestEnabled =false;
			}else {
				GET.InfoItem.TestEnabled=true;
			}
		}
		
		// are there collisions?
		// by default, yes there are, but now we see special kind of objects:
		GET.InfoItem.TestCollisions=true;

		switch (Slot) {
		case 86:  // WRAITH1
		case 87:  // WRAITH2
		case 88:  // WRAITH3
		case 89:  // WRAITH4
		case 115:  // DART_EMITTER
		case 142:  // FLAME
		case 143: // FLAME_EMITTER
		case 144:  // FLAME_EMITTER2
		case 145:  // FLAME_EMITTER3
		case 380: // SMOKE_EMITTER_WHITE
		case 381: // SMOKE_EMITTER_BLACK
		case 382: // STEAM_EMITTER
		case 383: // EARTHQUAKE
		case 384: // BUBBLES
		case 385: // WATERFALLMIST
			GET.InfoItem.TestCollisions=false;
			break;
		default:
			// all other items:
			if (GET.InfoItem.TestDoor==true && GET.InfoItem.TestEnabled == true) {
				// it is a door and it is open: no collisions
				GET.InfoItem.TestCollisions=false;
			}else {
				// for other items, verify with collision procedure
				if (pSlot->pProcCollision == NULL) {
					// missing collision procedure: no collision
					GET.InfoItem.TestCollisions=false;
				}
			}
			break;
		}


		break;

	case GET_LARA:
		GET.pLara = Trng.pGlobTomb4->pAdr->pLara;
		GET.LaraIndex = *Trng.pGlobTomb4->pAdr->pLaraIndex;
		break;
	case GET_ITEM:
		GET.pItem=NULL;

		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			TombIndex=FromNgleIndexToTomb4Index(Index);
			if (TombIndex==-1) return false;
			Index= TombIndex;
		}
		if (Index < 0 || Index >= Trng.pGlobTomb4->pAdr->TotItemsMax) {
			SendToLog("ERROR: Get(GET_ITEM) invalid item index (%d), outside of valid range 0 - %d",
				Index, Trng.pGlobTomb4->pAdr->TotItemsMax);
			return false;
		}
		GET.pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];
		break;
	case GET_STATIC:
		GET.pStatic=NULL;

		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==false) return false;

		}else {
			RoomIndex = Index;
			StaticIndex = SecondaryIndex;
		}
		if (RoomIndex < 0 || RoomIndex >= *Trng.pGlobTomb4->pAdr->pTotRooms) {
			SendToLog("ERROR: Get(GET_STATIC) Invalid room index (%d), outside of valid range 0 - %d",
					RoomIndex, *Trng.pGlobTomb4->pAdr->pTotRooms);
			return false;
		}
		z= Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].TotStaticMesh;

		if (StaticIndex < 0 || StaticIndex >= z) {
			SendToLog("ERROR: Get(GET_STATIC) Invalid static index (%d), outside of valid range 0 - %d",
				StaticIndex, z);
			return false;
		}
		GET.pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];
		break;
	case GET_ROOM:

		GET.pRoom=NULL;

		if (Index < 0 || Index >= *Trng.pGlobTomb4->pAdr->pTotRooms) {
			SendToLog("ERROR: Get(GET_ROOM) invalid index (%d), outside of valid range 0 - %d",
							Index, *Trng.pGlobTomb4->pAdr->pTotRooms);
			return false;
		}
		GET.pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[Index];
		break;
	case GET_COLOR_RGB:
		TestConvert=true;
		if (SecondaryIndex == COLF_TOMB_COLOR) TestConvert=false;

		GET.Color = GetColorRgb(Index, 0xFF000000, TestConvert, "Get() function");
		break;

	case GET_ITEM_COLL_BOX:
		GET.pCollItem=NULL;

		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			TombIndex=FromNgleIndexToTomb4Index(Index);
			if (TombIndex==-1) return false;
			Index= TombIndex;
		}
		if (Index < 0 || Index >= Trng.pGlobTomb4->pAdr->TotItemsMax) {
			SendToLog("ERROR: Get(GET_COLL_BOX) invalid item index (%d), outside of valid range 0 - %d",
				Index, Trng.pGlobTomb4->pAdr->TotItemsMax);
			return false;
		}
		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];		
		GET.pCollItem = GetBestFrame(pItem);
		break;
	case GET_STATIC_COLL_BOX:
	case GET_STATIC_VIEW_BOX:
		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==false) return false;

		}else {
			RoomIndex = Index;
			StaticIndex = SecondaryIndex;
		}
		if (RoomIndex < 0 || RoomIndex >= *Trng.pGlobTomb4->pAdr->pTotRooms) {
			SendToLog("ERROR: Get(GET_STATIC_COLL//VIEW_BOX) Invalid room index (%d), outside of valid range 0 - %d",
					RoomIndex, *Trng.pGlobTomb4->pAdr->pTotRooms);
			return false;
		}

		z= Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].TotStaticMesh;
		if (StaticIndex < 0 || StaticIndex >= z) {
			SendToLog("ERROR: Get(GET_STATIC_COLL/VIEW_BOX) Invalid static index (%d), outside of valid range 0 - %d",
				StaticIndex, z);
			return false;
		}
		pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];
		Index= pStatic->SlotId;
		if (GET_Type == GET_STATIC_COLL_BOX) {
			GET.pCollStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[Index].CollisionBox;
		}else {
			GET.pViewStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[Index].ViewBox;
		}
		break;
	case GET_DOOR_OF_ROOM:
		GET.pDoor=NULL;

		z= Trng.pGlobTomb4->pAdr->pVetRooms[Index].pDoors->TotDoors;

		if (Index < 0 || Index >= z) {
			SendToLog("ERROR: Get(GET_DOOR_OF_ROOM) invalid door index (%d), outside of valid range 0 - %d",
					Index, z);
			return false;
		}
		GET.pDoor = &Trng.pGlobTomb4->pAdr->pVetRooms[Index].pDoors->VetDoors[SecondaryIndex];
		break;

	case GET_INFO_LARA:
		pInfo = &GET.LaraInfo;
		// clear old values
		ClearMemory(pInfo, sizeof(StrLaraInfo));

		pInfo->TestFreeHands=true;
		// get some data we'll use to discover infos about lara:
		StateId = Trng.pGlobTomb4->pAdr->pLara->StateIdCurrent;
		pLara = Trng.pGlobTomb4->pAdr->pLara;
		pInfo->SkipPhaseFlags  =FindSkipPhase();



		// ------------ what item lara is holding in her hands --------------------------
		if (*Trng.pGlobTomb4->pAdr->pFlagsLaraHands == enumFLH.HOLDS_ITEM ||
			*Trng.pGlobTomb4->pAdr->pObjInLaraHandsNow == enumHOLD.FLARE ) {
			pInfo->TestFreeHands=false;
			// lara holds item in her hands
			pInfo->TestIsHoldingItem = true;
			pInfo->HoldedItem = *Trng.pGlobTomb4->pAdr->pObjInLaraHandsNow;
			// if item is flare, set also value of flaretime
			if (pInfo->HoldedItem == enumHOLD.FLARE) {
				pInfo->FlareTime = *Trng.pGlobTomb4->pAdr->pFlareLifeTime;
			}
			
			// if item is torch, verify if it's burning

			if (pInfo->HoldedItem == enumHOLD.OUT_TORCH ) {
				if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.TORCH_IS_BURNING ) {
					pInfo->HoldedItem = enumHOLD.FIRED_TORCH;
					pInfo->TestBurningTorch=true;
				}
			}
			// check if it is a weapon
			if (pInfo->HoldedItem >= enumHOLD.PISTOLS  && pInfo->HoldedItem <= enumHOLD.CROSSBOW ) {
				pInfo->TestIsHoldingWeapon = true;
			}
		}
		// ------------ weapon selected -------------------------------
		pInfo->WeaponSelected = *Trng.pGlobTomb4->pAdr->pWeaponSelected;

		// ------------ vehicle -------------------
		pInfo->IndexOfVehicle = *Trng.pGlobTomb4->pAdr->pVehicleIndex;
		if (pInfo->IndexOfVehicle != -1) {
			pInfo->TestFreeHands=false;
			pInfo->TestIsDrivingVehicle=true;
			pInfo->SlotVehicle = Trng.pGlobTomb4->pAdr->pVetItems[pInfo->IndexOfVehicle].SlotID;
		}
		// --------- crowbar --------------------
		// the only way to discover if lara is holding the crowbar is checking the value of right hand mesh and 
		// compare it with the same mesh of CROWBAR_ANIM

		// locate the first mesh for CROWBAR_ANIM slot
		MeshIndex= Trng.pGlobTomb4->pAdr->pVetSlot[enumSLOT.CROWBAR_ANIM].IndexFirstMesh;
		// the right hand the mesh with index = 10 but in the game all meshes are duplicated, so we have 
		// to multiply by 2 the real mesh index
		pMeshRightHand = Trng.pGlobTomb4->pAdr->VetMeshPointer[MeshIndex+ 10*2];
		// now we check if the mesh currently loaded in lara's body has same value of MeshRightHand
		// note: the mesh vector for current lara meshes is not duplicated so in this case we'll use 10 as index for right hand
		if (pMeshRightHand == Trng.pGlobTomb4->pAdr->VetMeshLara[10]) {
			// yes: lara is holding the crowbar
			pInfo->TestIsHoldingCrowBar=true;
			pInfo->TestFreeHands=false;
		}
		
		// ---------- rope -----------------------
		pInfo->RopeIndex = *Trng.pGlobTomb4->pAdr->pRopeNowIndex;
		if (pInfo->RopeIndex != -1) {
			pInfo->TestFreeHands=false;
			pInfo->TestIsOnRope=true;

		}
		// --------- polerope --------------------------

		pInfo->PoleRopeIndex=-1;
		if (StateId >= 99 && StateId <= 103) {
			// lara is hanged on pole rope
			pInfo->PoleRopeIndex = *Trng.pGlobTomb4->pAdr->pObjectActive;
			pInfo->TestIsOnRope = true;
			pInfo->TestFreeHands=false;
		}

		// ----------- is climbing? ------------------------
		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_CLIMBING ) {
			pInfo->TestIsClimbing=true;
			pInfo->TestFreeHands=false;
		}

		// ------------- is monkeying ? -----------------------------
		if ((StateId >= 0x4b && StateId <= 0x4f) || 
			StateId == 0x52 || StateId == 0x53) {
			pInfo->TestIsMonkeying=true;
			pInfo->TestFreeHands=false;
		}

		// ------------- on all fours ----------------------------------
		if (StateId >= 0x50 && StateId <= 0x58) {
			pInfo->TestIsOnAllFour=true;
		}

		// ------------- duck -------------------------------------------
		if (StateId == 0x47 || StateId == 0x48) {
			pInfo->TestIsDucking = true;
		}
		// ------------ is burning? -------------------------------------
		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_BURNING ) {
			pInfo->TestIsBurning = true;
		}
		
		// ------------- is immortal ? ------------------------------------
		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_INVULNERABLE ) {
			pInfo->TestIsImmortal = true;
		}
		// ------------- is dripping ? -----------------------------------
		for (i=0;i<16;i++) {
			if (Trng.pGlobTomb4->pAdr->pVetDrip[i]) {
				pInfo->TestIsDripping=true;
				break;
			}
		}

		// ------------- is poisoned ? ------------------------------------
		if (*Trng.pGlobTomb4->pAdr->pPoison1 != 0 || *Trng.pGlobTomb4->pAdr->pPoison2) {
			pInfo->TestIsPoisoned=true;
		}

		// ------------- is falling ? --------------------------------------
		if (pLara->FlagsMain & 0x008) {
			pInfo->TestIsFalling=true;
		}

		// ------------- is rushing ? ---------------------------
		if (StateId == 0x49) {
			pInfo->TestIsRushing = true;
			pInfo->RushValue = *Trng.pGlobTomb4->pAdr->pDashBarValue;
		}
		// ------------- using laser sight ? ---------------------
		if (pInfo->SkipPhaseFlags & enumSKIP.LASER_SIGHT) {
			pInfo->TestIsUsingLaserSight=true;
			pInfo->TestFreeHands=false;
		}

		// ------------ using binoculars ? -------------------------
		if (pInfo->SkipPhaseFlags & enumSKIP.BINOCULARS) {
			pInfo->TestIsUsingBinoculars=true;
			pInfo->TestFreeHands=false;
		}
		// ---------- lara is aiming an enmey? ----------------------
		pInfo->pStrAimedEnemy = *Trng.pGlobTomb4->pAdr->p2CurrentEnemyTarget;
		if (pInfo->pStrAimedEnemy != NULL) {
			pInfo->TestIsAimingEnemy = true;
		
		}

		// ----------- lara is pushing pushable object? ------------------
		if (StateId == 0x24 || StateId == 0x25) {

			Index = *Trng.pGlobTomb4->pAdr->pObjectActive;
			if (Index != -1) {
				Slot = Trng.pGlobTomb4->pAdr->pVetItems[Index].SlotID;

				if (Slot >= enumSLOT.PUSHABLE_OBJECT1 && Slot <= enumSLOT.PUSHABLE_OBJECT5) {
					if (StateId == 0x24) {
						pInfo->TestIsPushingItem=true;
						pInfo->PushableIndex = Index;
						pInfo->PushableSlot = Slot;
						pInfo->TestFreeHands=false;
					}
					// ----------- lara is pulling pushable object ? ----------------
					if (StateId == 0x25) {
						pInfo->TestIsPushingItem=true;
						pInfo->PushableIndex = Index;
						pInfo->PushableSlot = Slot;
						pInfo->TestFreeHands=false;
					}
				}
			}
		}

		// ------- environment of lara ---------------------------
		Flags= *Trng.pGlobTomb4->pAdr->pLaraLocationFlags;

		if (Flags == enumLLF.FLOATING) {
			pInfo->TestEnvFloatingOnWater =true;
		}
		if (Flags== enumLLF.GROUND ) {
			pInfo->TestEnvGround =true;
		}

		if (Flags == enumLLF.LOW_WATER) {
			pInfo->TestEnvLowWater =true;
		}

		if (Flags == enumLLF.UNDERWATER) {
			pInfo->TestEnvUnderwater = true;
		}

		if (Flags == enumLLF.DOZY ) {
			pInfo->TestEnvSpecial = true;
		}

		// ---------------------- Air available --------------------
		pInfo->AirValue = *Trng.pGlobTomb4->pAdr->pAirAvailable;

		// ------------------- Aligned orienting of Lara ---------------------------
		pInfo->OrientAligned = GetAlignedOrient(pLara->OrientationH, false, &pInfo->OrientGap);

		break;
	case GET_MY_PARAMETER_COMMAND:
		// ---------------- locate my parameter command ------------------
		GET.pParam=NULL;

		for (i=0;i<MyData.BaseParametersMine.TotParameters;i++) {
			pParam= &MyData.BaseParametersMine.pVetParameters[i];

			if (pParam->ParamValue == Index) {
				if (SecondaryIndex == -1 || SecondaryIndex == pParam->pVetArg[0]) {
					GET.pParam = pParam;
					break;
				}
			}
		}
		if (i == MyData.BaseParametersMine.TotParameters) {
			// not found parameter with given input values
			SendToLog("ERROR: not found my PARAMETERS of PARAM_ type %d with (further) ID = %d",
				Index, SecondaryIndex);

			return false;
		}
		GET.pParam = pParam;
		break;

	case GET_MY_CUSTOMIZE_COMMAND:
		GET.pCust=NULL;

		// ------------ find my customize command ----------------------
		for (i=0;i<MyData.BaseCustomizeMine.TotCustomize;i++) {
			pCust = &MyData.BaseCustomizeMine.pVetCustomize[i];

			if (pCust->CustValue == Index) {
				if (SecondaryIndex == -1 || SecondaryIndex == pCust->pVetArg[0]) {
					GET.pCust = pCust;
					break;
				}
			}
		}
		if (i== MyData.BaseCustomizeMine.TotCustomize) {
			// not found, giving warning only if it has been given also a specific ID
			if (SecondaryIndex != -1) {
				SendToLog("WARNING: not found my CUSTOMIZE with CUST_ value=%d and ID = %d",
					Index, SecondaryIndex);
			}
			return false;
		}
		GET.pCust = pCust;
		break;
	case GET_INPUT:
		// --------- locate input of keyboard/joystick ----------------------
		GET.Input.GameCommandsRead = *Trng.pGlobTomb4->pAdr->pInputGameCommands;
		GET.Input.pGameCommandsWrite = Trng.pGlobTomb4->pAdr->pInputGameCommands;
		GET.Input.InventoryCommandsRead = *Trng.pGlobTomb4->pAdr->pInputExtGameCommands;
		GET.Input.VetScanCode = Trng.pGlobTomb4->pAdr->pVetInputKeyboard;
		
		break;
	case GET_SCRIPT_SETTINGS:
		pScript= &GET.ScriptSettings;
		
		if (Trng.pGlobTomb4->ScriptOptions.MainFlags & 1) {
			pScript->TestDiagnostic=true;
		}else {
			pScript->TestDiagnostic=false;
		}

		pScript->pFMV_Extension = &Trng.pGlobTomb4->pAdr->pScriptDat[0x29];

		pScript->FlagsMain = *Trng.pGlobTomb4->pAdr->pScriptMainFlags;
		pScript->FlagsLevel = *Trng.pGlobTomb4->pAdr->pScriptLevelFlags;
		pScript->DiagnosticDGX = Trng.pGlobTomb4->pDiagnostica->FlagsDgx;
		pScript->DiagnosticEDGX = Trng.pGlobTomb4->pDiagnostica->DgxExtra;
		break;
	case GET_STRINGNG:
		GET.pStringNG = GetString(Index | STRING_NG);
		break;
	case GET_STRING:
		GET.pString = GetString(Index);
		break;
	case GET_BIG_NUMBER:
		GET.BigNumber=0;
		if (Index < 0 || Index >= Trng.pGlobTomb4->TotBigNumbers) {
			SendToLog("ERROR: Get(GET_BIG_NUMBER) invalid index (%d) for big number, outside of valid range 0 - %d",
				Index, Trng.pGlobTomb4->TotBigNumbers);
			return false;
		}
		GET.BigNumber = Trng.pGlobTomb4->VetBigNumbers[Index];
		break;
	case GET_PROGRESSIVE_ACTION:
		GET.pAction = GetNewProgrAction();
		break;
	case GET_AI_ITEM:
		GET.pAI=NULL;
		z= *Trng.pGlobTomb4->pAdr->pTotAIData;
		if (Index < 0 || Index >= z) {
			SendToLog("ERROR: Get(GET_AI_ITEM) invalid index (%d), outside of valid range 0 - %d",
				Index, z);
			return false;
		}
		GET.pAI = &Trng.pGlobTomb4->pAdr->pVetAIData[Index];
		break;		
	case GET_LIGHT:
		GET.pLight=NULL;

		z= *Trng.pGlobTomb4->pAdr->pTotRooms;

		if (Index < 0 || Index >= z) {
			SendToLog("ERROR: Get(GET_LIGHT) invalid room index (%d), outside of valid range 0 - %d",
					Index, z);
			return false;
		}

		z= Trng.pGlobTomb4->pAdr->pVetRooms[Index].TotLights;
		if (SecondaryIndex < 0 || SecondaryIndex >= z) {
			SendToLog("ERROR: Get(GET_LIGHT) invalid SecondaryIndex (%d), outside of valid range 0 - %d",
				SecondaryIndex, z);
			return false;
		}

		GET.pLight = &Trng.pGlobTomb4->pAdr->pVetRooms[Index].pLights[SecondaryIndex];
		break;
	case GET_CAMERA:
		GET.pCamera=NULL;
		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			TombIndex=FromNgleIndexToTomb4Index(Index);
			if (TombIndex==-1) return false;
			Index= TombIndex;
		}
		z= *Trng.pGlobTomb4->pAdr->Camera.pTotCameras;
		if (Index < 0 || Index >= z) {
			SendToLog("ERROR: Get(GET_CAMERA), invalid index (%d), outside of valid range 0 - %d",
				Index, z);
			return false;
		}
		GET.pCamera = &Trng.pGlobTomb4->pAdr->Camera.pVetCamera[Index];
		break;
	case GET_CAMERA_FLY:
		if (Index & NGLE_INDEX) {
			Index &= MASK_NGLE_INDEX;
			TombIndex=FromNgleIndexToTomb4Index(Index);
			if (TombIndex==-1) return false;
			Index= TombIndex;
		}
		GET.pCameraFly=NULL;
		z= *Trng.pGlobTomb4->pAdr->pTotFlyBy;
		if (Index < 0 || Index >= z) {
			SendToLog("ERROR: Get(GET_CAMERA_FLY), invalid index (%d), outside of valid range 0 - %d",
				Index, z);
			return false;
		}
		GET.pCameraFly = &Trng.pGlobTomb4->pAdr->pVetFlyBy[Index];
		break;
	case GET_GAME_INFO:
		pGame = &GET.GameInfo;

		pGame->FrameCounter = *Trng.pGlobTomb4->pAdr->pFrameCounter;
		pGame->LevelIndex= *Trng.pGlobTomb4->pAdr->pLevelNow;
		pGame->RowHeight = *Trng.pGlobTomb4->pAdr->pRowCharHeight;
		pGame->ScreenSizeX = *Trng.pGlobTomb4->pAdr->pSizeScreenX;
		pGame->ScreenSizeY = *Trng.pGlobTomb4->pAdr->pSizeScreenY;
		pGame->TestVolumetric=false;
		if (*Trng.pGlobTomb4->pAdr->pSetting_Volumetric != 0) {
			pGame->TestVolumetric =true;
		}

		pGame->AudioTrack = *Trng.pGlobTomb4->pAdr->pCDTrackNow;
		pGame->TestAudioLooped=false;
		if (*Trng.pGlobTomb4->pAdr->pAudioTrackLoop != 0) {
			pGame->TestAudioLooped=true;
		}

		pGame->TestExclusiveVideo = IsFullScreenMode();
		pGame->pVar = Trng.pGlobTomb4->pBaseVariableTRNG;
	
	
		break;
	case GET_SLOT:
		if (Index < 0 || Index >= enumSLOT.NUMBER_OBJECTS) {
			SendToLog("ERROR: Get(GET_SLOT) Invalid index value (%d), outside of valid range 0 - %d", Index,
				enumSLOT.NUMBER_OBJECTS);
			return false;
		}
		GET.pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[Index];
		break;
	case GET_INVENTORY:
		GET.pInventory = Trng.pGlobTomb4->pAdr->pInventory;
		GET.InventoryData.pItemPresence = GET.pInventory;
		GET.InventoryData.pChosenItemSlot = Trng.pGlobTomb4->pAdr->pInventoryChosenItem;
		GET.InventoryData.pRequiredItemSlot = Trng.pGlobTomb4->pAdr->pInventoryRequiredSlotItem;
		break;
	case GET_ANIMATION:
		GET.pAnimation = &Trng.pGlobTomb4->pAdr->pVetAnimations[Index];
		break;
	default:
		SendToLog("ERROR: unknown meaning of GET_ constant with value = %d", GET_Type);
		return false;

	}


	return true;
	
}

// FOR_YOU
// Find() function looks for some item and return found values in FIND structure
// if it doesn't find anything it will return "false"
// returned values are always indices of given items stored in vectors
bool Find(int FindType, short SlotType, short RoomIndex, short Ocb, int Extra, void *pPointer)
{
	int IndexNow;
	StrItemTr4 *pItem;
	bool TestOk;
	int i;
	StrProgressiveAction *pAction;
	int z;
	StrRoomTr4 *pRoom;
	int FirstRoomIndex;
	StrFlyByTr4 *pFly;
	int LastRoomIndex;
	int j;
	StrMeshInfo *pStatic;
	StrAIDataTr4 *pAI;
	StrTriplePoint *pPos;
	short NewRoom;
	DWORD MinX, MaxX, MinZ, MaxZ;


	switch (FindType)
	{
	case FIND_ASSIGN_SLOT_MINE:
		FIND.SlotAssigned = -1;

		for (i=0;i<MyData.BaseAssignSlotMine.TotAssign;i++) {
			if (MyData.BaseAssignSlotMine.VetAssignSlot[i].TipoSlot == SlotType) {
				FIND.SlotAssigned= MyData.BaseAssignSlotMine.VetAssignSlot[i].MioSlot;
				break;
			}
		}
		if (FIND.SlotAssigned==-1) return false;
		break;

	case FIND_PROGR_ACTION_TRNG:
		FIND.TotProgAxnTrng=0;
		pAction = &Trng.pGlobTomb4->VetProgressiveActions[0];
		for (i=0;i<Trng.pGlobTomb4->TotProgressiveActions;i++) {
			if (pAction->ActionType == SlotType && 
				(Extra == -1 || Extra == pAction->ItemIndex)) {
				// found a trng action
				FIND.pVetProgAxnTrng[FIND.TotProgAxnTrng++] = pAction;
			}
			pAction++;
		}
		if (FIND.TotProgAxnTrng==0) return false;
		break;

	case FIND_PROGR_ACTION_MINE:
		FIND.TotProgAxnMine=0;
		pAction = &MyData.VetProgrActions[0];
		for (i=0;i<MyData.TotProgrActions;i++) {
			if (pAction->ActionType == SlotType && 
				(Extra == -1 || Extra == pAction->ItemIndex)) {
				// found an action of mine
				FIND.pVetProgAxnMine[FIND.TotProgAxnMine++] = pAction;
			}
			pAction++;
		}
		if (FIND.TotProgAxnMine == 0) return false;
		break;

	case FIND_ENEMY_COMMAND:
		FIND.pEnemy=NULL;
		// looks for enemy= script command with Slot = Slot
		for (i=0;i<Trng.pGlobTomb4->BaseEnemys.TotEnemy;i++) {
			if (Trng.pGlobTomb4->BaseEnemys.VetEnemy[i].SlotId == SlotType) {
				FIND.pEnemy = &Trng.pGlobTomb4->BaseEnemys.VetEnemy[i];
				break;
			}
		}

		if (FIND.pEnemy==NULL) return false;
		break;

	case FIND_IMAGE_COMMAND:
		FIND.pImage=NULL;
		// looks for Image= script command with Id = Extra
		
		j= Trng.pGlobTomb4->pBaseScriptImages->VetID[Extra];
		
		if (j == -1) return false;

		FIND.pImage = &Trng.pGlobTomb4->pBaseScriptImages->VetImages[j];
		break;

	case FIND_WINDOWS_FONT:
		FIND.pWindowsFont=NULL;

		j= Trng.pGlobTomb4->BaseFonts.VetID[Extra];
		if (j==-1) return false;

		FIND.pWindowsFont = &Trng.pGlobTomb4->BaseFonts.VetFonts[j];
		break;

	case FIND_DIAGNOSTIC:
		FIND.Dgx.FlagsDgx= Trng.pGlobTomb4->pDiagnostica->FlagsDgx;
		FIND.Dgx.DgxExtra = Trng.pGlobTomb4->pDiagnostica->DgxExtra;
		FIND.Dgx.pLogItem = &Trng.pGlobTomb4->pDiagnostica->LogItem;
		break;
		

	case FIND_ITEM:
		FIND.TotItems=0;

		// it will be very different the code in according wether RoomIndex has been suplied or less
		if (RoomIndex != -1) {
			// RoomIndex has a valid value: looking for movables chain of given room
			IndexNow = Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].FirstItemIndex;
			while (IndexNow != -1) {
			
				pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];
				// if this item has SlotType and Ocb as required store its index
				TestOk=true;
				
				if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;
				if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

				if (TestOk == true) {
					FIND.VetItems[FIND.TotItems] = IndexNow;
					FIND.TotItems++;
				}
				// detect next moveable in this room
				IndexNow= pItem->ItemIndexNext;
			}

			if (FIND.TotItems==0) return false;
			break;
		}

		// missing RoomIndex: looking for moveable in all moveable items of the level
		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[0];
		for (i=0;i< Trng.pGlobTomb4->pAdr->TotItemsMax;i++) {
			TestOk=true;

			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;

			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

			if (TestOk == true) {
				FIND.VetItems[FIND.TotItems] = i;
				FIND.TotItems++;
								
			}
			pItem++; 
		}

		if (FIND.TotItems==0) return false;
		break;
	case FIND_STATICS_SECTOR:
		FIND.TotStatics=0;
		pPos = (StrTriplePoint*) pPointer;
		if (RoomIndex == -1) {
			SendToLog("ERROR: in Get(FIND_STATICS_SECTOR,): missing valid room index");
			return false;
		}
		NewRoom = RoomIndex;

		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

		// compute the bondary coordinates of current sector
		MinX = pPos->CordX & ~0x3ff;
		MinZ = pPos->CordZ & ~0x3ff;

		MaxX = MinX + 1023;
		MaxZ = MinZ + 1023;

		for (i=0;i<pRoom->TotStaticMesh;i++) {
			pStatic = &pRoom->Ptr_StaticMesh[i];

			if (pStatic->x >= MinX && pStatic->x <= MaxX &&
				pStatic->z >= MinZ && pStatic->z <= MaxZ) {

				FIND.VetStatics[FIND.TotStatics].ObjIndex = i;
				FIND.VetStatics[FIND.TotStatics].RoomIndex = NewRoom;
				FIND.TotStatics++;
			}
		}
		if (FIND.TotStatics ==0) return false;
		break;

	case FIND_STATICS_NEARBY:
		FIND.TotStatics=0;
		pPos = (StrTriplePoint*) pPointer;
		if (RoomIndex == -1) {
			SendToLog("ERROR: in Get(FIND_STATICS_NEARBY,): missing valid room index");
			return false;
		}
		NewRoom = RoomIndex;

		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];
		for (i=0;i<pRoom->TotStaticMesh;i++) {
			pStatic = &pRoom->Ptr_StaticMesh[i];

			if (GetDistanceXZY(pPos->CordX, pPos->CordY, pPos->CordZ, 
				pStatic->x, pStatic->y, pStatic->z) <= Extra) {
				FIND.VetStatics[FIND.TotStatics].ObjIndex = i;
				FIND.VetStatics[FIND.TotStatics].RoomIndex = NewRoom;
				FIND.TotStatics++;
			}
		}
		if (FIND.TotStatics ==0) return false;
		break;
		
	case FIND_ITEMS_NEARBY:
		FIND.TotItems=0;
		pPos = (StrTriplePoint*) pPointer;
		if (RoomIndex == -1) {
			SendToLog("ERROR: in Get(FIND_ITEMS_NEARBY,): missing valid room index");
			return false;
		}
		NewRoom = RoomIndex;

		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

		IndexNow =pRoom->FirstItemIndex;

		while (IndexNow != -1) {
		
			pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];
			// first to check if this item has SlotType and Ocb as required
			TestOk=true;
			
			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;
			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

			if (TestOk == true) {
				// verify distance

				if (GetDistanceXZY(pPos->CordX, pPos->CordY, pPos->CordZ, 
										pItem->CordX, pItem->CordY, pItem->CordZ) <= Extra) {

					FIND.VetItems[FIND.TotItems] = IndexNow;
					FIND.TotItems++;
				}
			
			}
			// detect next moveable in this room
			IndexNow= pItem->ItemIndexNext;
		}
		if (FIND.TotItems == 0) return false;
		break;

	case FIND_ITEMS_SECTOR:
		FIND.TotItems=0;
		pPos = (StrTriplePoint*) pPointer;

		if (RoomIndex == -1) {
			SendToLog("ERROR: in Get(FIND_ITEMS_SECTOR,): missing valid room index");
			return false;
		}

		NewRoom = RoomIndex;

		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

		// compute the bondary coordinates of current sector
		MinX = pPos->CordX & ~0x3ff;
		MinZ = pPos->CordZ & ~0x3ff;

		MaxX = MinX + 1023;
		MaxZ = MinZ + 1023;


		IndexNow =pRoom->FirstItemIndex;

		while (IndexNow != -1) {
		
			pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];
			// first to check if this item has SlotType and Ocb as required
			TestOk=true;
			
			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;
			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

			if (TestOk == true) {
				// verify if the item is in boundaries of current sector

				if (pItem->CordX >= MinX && pItem->CordX <= MaxX && 
					pItem->CordZ >= MinZ && pItem->CordZ <= MaxZ) {

					FIND.VetItems[FIND.TotItems] = IndexNow;
					FIND.TotItems++;
				}
			
			}
			// detect next moveable in this room
			IndexNow= pItem->ItemIndexNext;
		}
		if (FIND.TotItems == 0) return false;
		break;

	case FIND_STATIC:
		FIND.TotStatics=0;
		// if it has been supplied the RoomIndex, looking for static only in that room
		if (RoomIndex != -1) {
			FirstRoomIndex = RoomIndex;
			LastRoomIndex = RoomIndex +1;
		}else {
			// otherwise, looking in all rooms
			FirstRoomIndex = 0;
			LastRoomIndex = *Trng.pGlobTomb4->pAdr->pTotRooms;
		}

		for (i=FirstRoomIndex;i<LastRoomIndex; i++) {
			pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[i];

			// parse all statics of this room

			for (j=0;j< pRoom->TotStaticMesh;j++) {
				
				pStatic = &pRoom->Ptr_StaticMesh[j];

				TestOk=true;

				if (SlotType != -1 && SlotType != pStatic->SlotId) TestOk=false;

				if (Ocb != -1 && Ocb != pStatic->OCB) TestOk=false;

				if (TestOk==true) {
					// save the indices
					z= FIND.TotStatics;

					FIND.VetStatics[z].RoomIndex = i;
					FIND.VetStatics[z].ObjIndex = j;
					FIND.TotStatics++;

				}
			}

		}
		if (FIND.TotStatics == 0) return false;
		break;
	case FIND_AI:
		FIND.TotAI=0;

		pAI= &Trng.pGlobTomb4->pAdr->pVetAIData[0];

		for (i=0;i<*Trng.pGlobTomb4->pAdr->pTotAIData;i++) {
			TestOk=true;

			if (RoomIndex != -1 && RoomIndex != pAI->RoomIndex) TestOk=false;

			if (Ocb != -1 && Ocb != pAI->Ocb) TestOk = false;

			if (SlotType != -1 && SlotType != pAI->SlotAI) TestOk=false;

			if (TestOk == true) {
				FIND.VetAI[FIND.TotAI] = i;
				FIND.TotAI++;
			}
			pAI++;

		}
		
		if (FIND.TotAI == 0) return false;
		break;
	case FIND_LIGHT:
		FIND.TotLights=0;
		// if it has been supplied the RoomIndex, looking for lights only in that room
		if (RoomIndex != -1) {
			FirstRoomIndex = RoomIndex;
			LastRoomIndex = RoomIndex +1;
		}else {
			// otherwise, looking in all rooms
			FirstRoomIndex = 0;
			LastRoomIndex = *Trng.pGlobTomb4->pAdr->pTotRooms;
		}

		for (i=FirstRoomIndex;i<LastRoomIndex;i++) {
			pRoom= &Trng.pGlobTomb4->pAdr->pVetRooms[i];


			for (j=0;j<pRoom->TotLights;j++) {
				if (SlotType==-1 || pRoom->pLights[j].LightType == SlotType) {
					z= FIND.TotLights;

					FIND.VetLights[z].RoomIndex = i;
					FIND.VetLights[z].ObjIndex = j;
					FIND.TotLights++;
				}
			}
		}
		if (FIND.TotLights==0) return false;

		break;
		
	case FIND_CAMERA_FIXED:
		FIND.TotCameraFix=0;
		
		for (i=0;i< *Trng.pGlobTomb4->pAdr->Camera.pTotCameras;i++) {
			if (Trng.pGlobTomb4->pAdr->Camera.pVetCamera[i].Room == RoomIndex) {
				FIND.VetCameraFix[FIND.TotCameraFix]= i;
				FIND.TotCameraFix++;
			}
		}
		if (FIND.TotCameraFix==0) return false;
		break;
		
	case FIND_CAMERA_FLY:
		FIND.TotCameraFly=0;

		pFly= &Trng.pGlobTomb4->pAdr->pVetFlyBy[0];
		
		for (i=0;i< *Trng.pGlobTomb4->pAdr->pTotFlyBy;i++) {

			TestOk=true;

			if (RoomIndex != -1 && pFly->RoomIndex != RoomIndex) TestOk=false;
			if (Ocb != -1 && pFly->CameraButtons != Ocb) TestOk=false;
			if (SlotType != -1 && pFly->Seq != SlotType) TestOk=false;
			if (Extra != -1 && pFly->Num != Extra) TestOk=false;

			if (TestOk == true) {
				FIND.VetCameraFly[FIND.TotCameraFly] = i;
				FIND.TotCameraFly++;
			}
			pFly++;
		}
		if (FIND.TotCameraFly == 0) return false;
		break;
		

	}

	return true;

}


// you call this funcition to singal that your GT_ global trigger is just happened, supplying further parameter
// The function returns "true" if there was a GlobalTrigger command that managed this GT_ event and 
// it has been performed the linked triggergroup 

bool DetectedGlobalTriggerEvent(int GT_Event, int Parameter, bool TestIgnoreParameter)
{
	int RetValue;

	RetValue = Service(SRV_F_DetectedGlobalTriggerEvent, GT_Event, Parameter, TestIgnoreParameter);
	if (RetValue != 0) return true;
	
	return false;

}
// receive in input Source x,y,z point and Target, x,y,z and returns the orienting that from source point looks 
// at target point
WORD GetDirection(DWORD SourceX, DWORD SourceZ, DWORD TargetX, DWORD TargetZ)
{
	WORD Orient;

	Orient = mGetAngle(SourceX, SourceZ, TargetX, TargetZ);
	Orient += 0x4000;

	return Orient;

}

// Check if Moveable Item (pSourceItem) is able to see the other moveable index (TargetIndex)
// if you set positive values for TolleranceH and/or TolleranceV) it will be considered also
// the facing of pSourceItem, while if set both tollerance at -1 -1, it will be used the source point
// regardless about where SourceItem is looking.
// returns true if there is free line between source item and target item, returns false
// if there is an obstacle. 
// some intermediate values will be saved in LOF (Line Of Fire) global structure.
bool CheckDirection(StrItemTr4 *pSourceItem, int OffSourceY, int TargetIndex, int OffTargetY, 
					short TolleranceH, short TolleranceV)
{
	

	short Orient;
	int Indice;
	int Index;
	StrItemTr4 *pTarget;
	DWORD  Alfa, Beta;
	short MyTolleranza;
	short HOrient;

	ClearMemory(&LOF, sizeof(StrLOFData));

	if (TargetIndex & NGLE_INDEX) {
		Index = TargetIndex & MASK_NGLE_INDEX;
		TargetIndex = FromNgleIndexToTomb4Index(Index);
		if (TargetIndex==-1) return false;
	}
	pTarget = &Trng.pGlobTomb4->pAdr->pVetItems[TargetIndex];

	MyTolleranza= TolleranceV;
	Orient= GetDirection(pSourceItem->CordX, pSourceItem->CordZ, pTarget->CordX, pTarget->CordZ);
	LOF.OrientingH = Orient;

	// calcolarlo angolo orizzontale 
	if (TolleranceH > 0) {


		HOrient=Orient;
		// ora calcolare differenza con facing di enemy
		if (AbsDiffO(Orient, pSourceItem->OrientationH) > TolleranceH) return false;

	}

	// stesso calcolo per differenza verticale
	if (MyTolleranza > 0) {
		// vedere se usare x o z
		// scegliere l'asse dove c'e' la distanza maggiore
		if (AbsDiff(pTarget->CordX, pSourceItem->CordX) > AbsDiff(pTarget->CordZ, pSourceItem->CordZ)) {
			// distanza x e' maggiore, usare  X
			Alfa = pSourceItem->CordX;
			Beta = pTarget->CordX;
		}else {
			// e' maggiore z usare Z
			Alfa = pSourceItem->CordZ;
			Beta = pTarget->CordZ;
		}
		if (GetMaxDistance(&pSourceItem->CordX, &pTarget->CordX,true) < 2048) {
			// aumentare la tolleranza se sono molto vicini
			MyTolleranza = MyTolleranza << 1;
		}
		Orient = mGetAngle(Alfa, pSourceItem->CordY+OffSourceY, Beta, pTarget->CordY+OffTargetY);
		if (Orient > 4096 || Orient < -4096) Orient += (short) 32767;	
		LOF.OrientingV = Orient;
		if (AbsDiffO(Orient, pSourceItem->OrientationV) > MyTolleranza) return false;

	}
	// la distanza tra lara e il nemico non deve superare i 10 blocchi
	if (GetDistanceXZ(pSourceItem->CordX, pSourceItem->CordZ, 
							pTarget->CordX, pTarget->CordZ) > 10240) return false;

	// l'orientamento generico va bene
	// ora vedere se non ci sono ostacoli 


	LOF.Src.CordX = pSourceItem->CordX;
	LOF.Src.CordZ = pSourceItem->CordZ;
	LOF.Src.CordY = pSourceItem->CordY + OffSourceY;
	LOF.Src.Room = pSourceItem->Room;

	LOF.Dest.CordX = pTarget->CordX;
	LOF.Dest.CordZ = pTarget->CordZ;
	LOF.Dest.CordY = pTarget->CordY + OffTargetY;
	LOF.Dest.Room = pTarget->Room;


	if (LOS(&LOF.Src,&LOF.Dest)==false) {
		LOF.PointFinal.OrgX = Trng.pGlobTomb4->DummyX;
		LOF.PointFinal.OrgY = Trng.pGlobTomb4->DummyY;
		LOF.PointFinal.OrgZ = Trng.pGlobTomb4->DummyZ;
		LOF.TestWall=true;
		return false;
	}

	Trng.pGlobTomb4->pItemAdrToIgnoreLOF = pSourceItem;

	Indice = ObjectOnLOS2(&LOF.Src, &LOF.Dest, &LOF.PointFinal , &LOF.pStaticFound);
	Trng.pGlobTomb4->pItemAdrToIgnoreLOF = NULL;

	if (Indice != 999 && Indice != TargetIndex) {
		LOF.pItemFound = &Trng.pGlobTomb4->pAdr->pVetItems[Indice];
		return false;
	}

	// non c'e'nessun oggetto diverso da quello scandito in mezzo
	// quindi ok
	LOF.TestFreeLine=true;
	return true;


	

}

// verify the slope direction of current sector following "rise" direction
// note: this function will use values in FLOOR structure, for this reason you should have already performed
// a call to CheckFloor() function for current sector
// this function will return an ORIENT_ direction
short GetSlopeDirection(void)
{

	// verifiy if is is a diagonal slope: in this case we'll return an invalid value to quit
	if (FLOOR.SlopeX !=0 && FLOOR.SlopeZ != 0) {
		// the sector is inclinated on two axis: diagonal direction
		if (FLOOR.SlopeZ > 0 && FLOOR.SlopeX > 0) {
			// south-east direction
			return enumORIENT.SOUTH_EAST;
		}

		if (FLOOR.SlopeZ > 0 && FLOOR.SlopeX < 0) {
			return enumORIENT.NORTH_EAST;
		}
		if (FLOOR.SlopeZ < 0 && FLOOR.SlopeX > 0) {
			return enumORIENT.SOUTH_WEST;
		}

		// it has to be north-west
		return enumORIENT.NORTH_WEST;

		
	}

	if (FLOOR.SlopeX > 0) {
		// south
		return enumORIENT.SOUTH;
	}

	if (FLOOR.SlopeX < 0) {
		// north
		return enumORIENT.NORTH;
	}

	if (FLOOR.SlopeZ > 0) {
		// east
		return enumORIENT.EAST;
	}

	if (FLOOR.SlopeZ < 0) {
		// west
		return enumORIENT.WEST;
	}

	// there is no slope, so neither a directio for the rise. Return an invalid value
	return 9999;

}




// perform an analysis about point of 3d world (x,y,z) supplied in input
// in spite of the name "floor" it returns result also about ceiling height and further water level
// all results will be returned in FLOOR global structure
// it returns immediatly "false" when the point is in the middle of a wall or outside of level map, 
// it returns true when there are valid values to analyse
// the RoomIndex you supply it's not necessariliy that of (x,y,z) point but it's better it was a room closed to that point
bool CheckFloor(DWORD x, int y, DWORD z, int RoomIndex)
{
	DWORD OrgX;
	DWORD OrgZ;
	WORD ClickGrade;
	
	ClearMemory(&FLOOR, sizeof(StrFloorAnalyse));

	OrgX = x & ~0x3ff;
	OrgZ = z & ~0x3ff;

	FLOOR.SectorCoords.WestZ = OrgZ;
	FLOOR.SectorCoords.SouthX = OrgX+1023;
	FLOOR.SectorCoords.EastZ = OrgZ + 1023;
	FLOOR.SectorCoords.NorthX = OrgX;
	FLOOR.SectorCoords.MiddleX = OrgX + 511;
	FLOOR.SectorCoords.MiddleZ = OrgZ + 511;
	FLOOR.SectorCoords.Radius = GetDistanceXZ(x, z, OrgX+511, OrgZ+511);
	FLOOR.RoomIndex = RoomIndex;

	FLOOR.pFloor = (WORD *) GetFloor(x,y,z, &FLOOR.RoomIndex);

	if (FLOOR.pFloor == NULL) {
		FLOOR.TestFullWall=true;
		return false;
	}

	FLOOR.FloorHeight = GetHeight(FLOOR.pFloor , x,y,z);
	
	if (FLOOR.FloorHeight == WALL_FLOOR) {
		FLOOR.TestFullWall=true;
		return false;
	}

	FLOOR.CeilingHeight = GetCeiling(FLOOR.pFloor, x, y, z);

	FLOOR.WaterDepth = GetWaterDepth(x,y,z, FLOOR.RoomIndex);
	FLOOR.WaterHeight = GetWaterHeight(x,y,z, FLOOR.RoomIndex);

	FLOOR.TestGraySector = IsGraySector(FLOOR.pFloor);

	FLOOR.ClimbStatus = FindClimbStatus(FLOOR.pFloor);

	if (FLOOR.ClimbStatus != 0) FLOOR.TestClimb=true;

	FLOOR.TestDeath = FindFloorType(FLOOR.pFloor, 5);
	FLOOR.TestMonkey = FindFloorType(FLOOR.pFloor, 0x13);

	FLOOR.SlopeType = *Trng.pGlobTomb4->pAdr->pSlopeType;
	FLOOR.SlopeX = *Trng.pGlobTomb4->pAdr->pSlopeX;
	FLOOR.SlopeZ = *Trng.pGlobTomb4->pAdr->pSlopeZ;

	FLOOR.SlopeOrienting = GetSlopeDirection();
	ClickGrade = abs(FLOOR.SlopeX);
	if (abs(FLOOR.SlopeZ) > ClickGrade) {
		ClickGrade = abs(FLOOR.SlopeZ);
	}
	FLOOR.SlopeClickGrade = ClickGrade;

	return true;

}
